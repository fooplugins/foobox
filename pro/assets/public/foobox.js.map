{"version":3,"file":"foobox.js","mappings":"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","sources":["webpack://foobox/webpack/runtime/chunk loaded","webpack://foobox/./src/utils/object.js","webpack://foobox/./src/utils/EmitterEvent.js","webpack://foobox/./src/utils/Emitter.js","webpack://foobox/./src/utils/task.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/config.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/config.pro.js","webpack://foobox/./src/public/foobox/ContainerController/GroupParser/config.pro.js","webpack://foobox/./src/utils/makeSelector.js","webpack://foobox/./src/public/foobox/ContainerController/Container/Item.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/TypeParser/PropertyParser/index.js","webpack://foobox/./src/utils/mergeArray.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/TypeParser/index.js","webpack://foobox/./src/public/foobox/ContainerController/Container/index.js","webpack://foobox/./src/utils/iasync.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/index.js","webpack://foobox/./src/public/foobox/config.pro.js","webpack://foobox/./src/public/foobox/ContainerController/config.pro.js","webpack://foobox/./src/public/foobox/ContainerController/GroupParser/index.js","webpack://foobox/./src/utils/index.js","webpack://foobox/./src/public/foobox/index.pro.js","webpack://foobox/./src/public/foobox/Plugin.js","webpack://foobox/./src/public/foobox/ContainerController/index.js","webpack://foobox/./src/utils/is.js","webpack://foobox/webpack/bootstrap","webpack://foobox/webpack/runtime/define property getters","webpack://foobox/webpack/runtime/global","webpack://foobox/webpack/runtime/hasOwnProperty shorthand","webpack://foobox/webpack/runtime/make namespace object","webpack://foobox/webpack/runtime/jsonp chunk loading","webpack://foobox/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import {isPlainObject, isStringNotEmpty, isUndefined} from \"./is\";\r\n\r\nfunction hasProperty(target, propertyName){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    return currentTarget.hasOwnProperty(name);\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return target.hasOwnProperty(propertyName);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Remove a property from an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n */\r\nfunction removeProperty(target, propertyName){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    delete currentTarget[name];\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                }\r\n            }\r\n        } else {\r\n            delete target[propertyName];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get the value of a property from an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n * @param {*} [defaultValue]\r\n * @returns {*}\r\n */\r\nfunction getProperty(target, propertyName, defaultValue){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    if (currentTarget.hasOwnProperty(name)){\r\n                        return currentTarget[name];\r\n                    }\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n        } else if (target.hasOwnProperty(propertyName)){\r\n            return target[propertyName];\r\n        }\r\n    }\r\n    return defaultValue;\r\n}\r\n\r\n/**\r\n * Set the value of a property in an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction setProperty(target, propertyName, value){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName) && !isUndefined(value)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    currentTarget[name] = value;\r\n                    return true;\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else if (isUndefined(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name] = {};\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            target[propertyName] = value;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Merge the properties of the source object into the target object replacing existing values.\r\n * @param {object} target - The object that will receive the properties.\r\n * @param {object} source - The object to extract properties from.\r\n * @returns {object}\r\n */\r\nfunction merge(target, source) {\r\n    target = isPlainObject(target) ? target : {};\r\n    if (isPlainObject(target) && isPlainObject(source)){\r\n        objForEach(source, (key, value) => {\r\n            if (isPlainObject(value)){\r\n                // if the source value is an object, merge it into the target key\r\n                target[key] = merge(target[key], value);\r\n            } else if (Array.isArray(value)){\r\n                // if the source value is an array, replace the target key with a shallow copy of it\r\n                target[key] = value.slice();\r\n            } else {\r\n                // otherwise replace the target key with the source value\r\n                target[key] = value;\r\n            }\r\n        });\r\n    }\r\n    // always return the original target object\r\n    return target;\r\n}\r\n\r\n/**\r\n * Merge the properties of all source objects into the target object replacing existing values.\r\n * @param {object} target\r\n * @param {...object} sources\r\n * @returns {object}\r\n */\r\nfunction extend(target, ...sources) {\r\n    target = isPlainObject(target) ? target : {};\r\n    return sources.reduce((result, source) => merge(result, source), target);\r\n}\r\n\r\n/**\r\n * Merge the properties of the source object into the target object if they do not exist.\r\n * @param {object} target - The object that will receive the properties.\r\n * @param {object} source - The object to extract properties from.\r\n * @returns {object}\r\n */\r\nfunction mergeMissing(target, source){\r\n    target = isPlainObject(target) ? target : {};\r\n    if (isPlainObject(source)){\r\n        objForEach(source, (key, value) => {\r\n            const missing = !target.hasOwnProperty(key);\r\n            if (isPlainObject(value)){ // if the source value is an object\r\n                if (isPlainObject(target[key])){ // and the target key is an object, merge the missing source properties\r\n                    target[key] = mergeMissing(target[key], value);\r\n                } else if (missing) { // otherwise if its missing, set the target key to the source value\r\n                    target[key] = merge({}, value);\r\n                }\r\n            } else if (missing) {\r\n                // if its just missing and not a special case, set the target key with the missing source value\r\n                target[key] = value;\r\n            }\r\n        });\r\n    }\r\n    // always return the original target object\r\n    return target;\r\n}\r\n\r\n/**\r\n * Merge the properties of all source objects into the target object if they do not exist.\r\n * @param {object} target\r\n * @param {...object} sources\r\n * @returns {object}\r\n */\r\nfunction defaults(target, ...sources){\r\n    target = isPlainObject(target) ? target : {};\r\n    return sources.reduce((result, source) => mergeMissing(result, source), target);\r\n}\r\n\r\n/**\r\n * @callback objForEach~callback\r\n * @param {string} key\r\n * @param {*} value\r\n */\r\n\r\n/**\r\n * Iterates all keys of the target and executes the callback for each supplying the current key and value.\r\n * @param {object} target - The target object to iterate.\r\n * @param {objForEach~callback} callback - The callback to execute.\r\n */\r\nfunction objForEach(target, callback){\r\n    Object.keys(target).forEach((key) => {\r\n        callback.call(this, key, target[key]);\r\n    });\r\n}\r\n\r\n/**\r\n * A \"reducer\" function that can take up to four arguments.\r\n * @callback objReduce~callback\r\n * @template T\r\n * @param {T} previousValue - The value resulting from the previous call to the callback.\r\n * @param {*} value - The value of the current key.\r\n * @param {string} [key] - The current key of the object.\r\n * @param {object} [object] - The object being iterated.\r\n * @returns {T}\r\n */\r\n/**\r\n * The objReduce() method executes a user-supplied “reducer” callback function on each key~value pair of the target object,\r\n * passing in the return value from the calculation on the preceding pair. The final result of running the reducer across\r\n * all key~value pairs of the target object is a single value.\r\n * @template T\r\n * @param {object} target - The object to reduce.\r\n * @param {objReduce~callback<T>} callbackFn - A \"reducer\" function that takes four arguments.\r\n * @param {T} [initialValue] - A value to which \"previousValue\" is initialized the first time the callback is called.\r\n * @returns {T} The value that results from running the “reducer” callback function to completion over the entire object.\r\n */\r\nfunction objReduce(target, callbackFn, initialValue){\r\n    return Object.keys(target).reduce((previousValue, key) => {\r\n        return callbackFn.call(this, previousValue, target[key], key);\r\n    }, initialValue);\r\n}\r\n\r\nexport {\r\n    objForEach,\r\n    objReduce,\r\n    hasProperty,\r\n    removeProperty,\r\n    getProperty,\r\n    setProperty,\r\n    merge,\r\n    extend,\r\n    mergeMissing,\r\n    defaults\r\n};","import {isBoolean, isPlainObject, isStringNotEmpty} from \"./is\";\r\nimport Emitter from \"./Emitter\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {object} EmitterEventOptions\r\n * @property {boolean} [bubbles=false] - Whether or not the event is bubbled.\r\n * @property {boolean} [cancelable=false] - Whether or not the event can be canceled using preventDefault.\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new EmitterEvent instance.\r\n * @class EmitterEvent\r\n * @param {string} type - The type of the event.\r\n * @param {EmitterEventOptions} [options] - The options for the event.\r\n * @param {Emitter} [target] - The target for the event.\r\n * @throws {TypeError} Throws a TypeError if the supplied `type` is invalid.\r\n */\r\nclass EmitterEvent {\r\n\r\n    //#region constructor\r\n\r\n    /**\r\n     * @constructs\r\n     * @param {string} type - The type of the event.\r\n     * @param {EmitterEventOptions} [options] - The options for the event.\r\n     * @param {Emitter} [target] - The target for the event.\r\n     * @throws {TypeError} Throws a TypeError if the supplied `type` is invalid.\r\n     */\r\n    constructor(type, options, target) {\r\n        const parsed = Emitter.parseType(type, true);\r\n        this.#type = parsed.type;\r\n        this.#namespace = parsed.namespace;\r\n        if (isPlainObject(options)){\r\n            this.#bubbles = isBoolean(options.bubbles) ? options.bubbles : false;\r\n            this.#cancelable = isBoolean(options.cancelable) ? options.bubbles : false;\r\n        }\r\n        if (target instanceof Emitter){\r\n            this.#target = this.#currenTarget = target;\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region properties\r\n\r\n    /**\r\n     * The private field used by the type read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #type;\r\n    /**\r\n     * The type of event.\r\n     * @type {string}\r\n     * @readonly\r\n     */\r\n    get type(){\r\n        return this.#type;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the namespace read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #namespace = null;\r\n    /**\r\n     * The namespace of the event.\r\n     * @type {?string}\r\n     * @readonly\r\n     * @default null\r\n     */\r\n    get namespace(){\r\n        return this.#namespace;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the bubbles read-only property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #bubbles = false;\r\n    /**\r\n     * Whether or not the event is bubbled.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get bubbles(){\r\n        return this.#bubbles;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the cancelable read-only property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #cancelable = false;\r\n    /**\r\n     * Whether or not the event is cancelable.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get cancelable(){\r\n        return this.#cancelable;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the defaultPrevented readonly property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #defaultPrevented = false;\r\n    /**\r\n     * Whether or not the event is cancelable and preventDefault has been called.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get defaultPrevented(){\r\n        return this.#defaultPrevented;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the target readonly property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #target = null;\r\n    /**\r\n     * The emitter that initially raised the event.\r\n     * @type {?Emitter}\r\n     * @default null\r\n     */\r\n    get target(){\r\n        return this.#target;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter that raised the event.\r\n     * @param {Emitter} emitterInstance\r\n     * @throws {TypeError} Throws a TypeError if the value is not an instance of Emitter.\r\n     */\r\n    set target(emitterInstance){\r\n        if (emitterInstance instanceof Emitter){\r\n            this.#target = emitterInstance;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The EmitterEvent.target must be an instance of Emitter.\");\r\n    }\r\n\r\n    /**\r\n     * The private field used by the currenTarget readonly property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #currenTarget = null;\r\n    /**\r\n     * The emitter currently raising the event.\r\n     * @type {?Emitter}\r\n     * @default null\r\n     */\r\n    get currenTarget(){\r\n        return this.#currenTarget;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter currently raising the event.\r\n     * @param {Emitter} emitterInstance\r\n     * @throws {TypeError} Throws a TypeError if the value is not an instance of Emitter.\r\n     */\r\n    set currenTarget(emitterInstance){\r\n        if (emitterInstance instanceof Emitter){\r\n            this.#currenTarget = emitterInstance;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The EmitterEvent.currenTarget must be an instance of Emitter.\");\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Specifies the default action should not be taken. Calling this method on a non-cancelable event has no effect.\r\n     */\r\n    preventDefault() {\r\n        if (!this.cancelable) return;\r\n        this.#defaultPrevented = true;\r\n    }\r\n\r\n    /**\r\n     * Whether or not the default action should not be taken.\r\n     * @returns {boolean}\r\n     */\r\n    isDefaultPrevented() {\r\n        return this.defaultPrevented;\r\n    }\r\n\r\n    #propagationStopped = false;\r\n    stopPropagation(){\r\n        this.#propagationStopped = true;\r\n    }\r\n\r\n    isPropagationStopped(){\r\n        return this.#propagationStopped;\r\n    }\r\n\r\n    //endregion\r\n\r\n}\r\n\r\nexport default EmitterEvent;","import {isFunction, isPlainObject, isStringNotEmpty, isUndefined} from \"./is\";\r\nimport EmitterEvent from \"./EmitterEvent\";\r\nimport {defaults, objForEach} from \"./object\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * A function that can handle an event emitted by an Emitter object.\r\n * @callback EmitterListener\r\n * @param {EmitterEvent} [event]\r\n * @param {...*} [args]\r\n */\r\n/**\r\n * An object containing event type to listener mappings.\r\n * @typedef {object} EmitterMap\r\n * @example\r\n *  {\r\n *      \"some-event\": (event, ...args) => { },\r\n *      \"another-event\": (event, ...args) => { }\r\n *  }\r\n */\r\n/**\r\n * The result of the Emitter.parseType method.\r\n * @typedef {object} EmitterType\r\n * @property {?string} [type] - The type of the event.\r\n * @property {?string} [namespace] - The namespace for the event.\r\n */\r\n/**\r\n * A map of event type to namespaces.\r\n * @typedef {Map<string, EmitterNamespaces>} EmitterEvents\r\n */\r\n/**\r\n * A map of namespace to listeners.\r\n * @typedef {Map<?string, EmitterListeners>} EmitterNamespaces\r\n */\r\n/**\r\n * A map of listener to thisArgs\r\n * @typedef {Map<EmitterListener, Set<*>>} EmitterListeners\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new Emitter instance.\r\n * @class Emitter\r\n * @param {EmitterEventOptions} [options] - The default options for events created by this instance.\r\n * @param {Emitter} [parentEmitter] - The parent emitter for this instance.\r\n */\r\nclass Emitter {\r\n\r\n    //region static\r\n\r\n    /**\r\n     * The separator used to parse eventType strings into there component type and namespace values.\r\n     * @type {string}\r\n     * @default \".\"\r\n     */\r\n    static EVENT_TYPE_NAMESPACE_SEPARATOR = \".\";\r\n\r\n    /**\r\n     * Parses the supplied event type string into its component type and namespace values.\r\n     * @param {string} type - The event type string to parse.\r\n     * @param {boolean} [required=false] - Whether or not to throw a TypeError if the parsed type is empty.\r\n     * @returns {EmitterType}\r\n     * @throws {TypeError} Throws a TypeError if the supplied `type` or return value is invalid.\r\n     */\r\n    static parseType(type, required){\r\n        if (!isStringNotEmpty(type)) {\r\n            throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        }\r\n        let namespace = null, parsedType = type;\r\n        const n_index = type.indexOf(this.EVENT_TYPE_NAMESPACE_SEPARATOR);\r\n        if (n_index !== -1){\r\n            namespace = type.slice(n_index + 1) || null;\r\n            parsedType = type.slice(0, n_index) || null;\r\n        }\r\n        if ((!namespace && !parsedType) || (!parsedType && required)){\r\n            throw new TypeError(`Unable to parse the event type: \"${type}\"`);\r\n        }\r\n        return { type: parsedType, namespace };\r\n    }\r\n\r\n    //endregion\r\n\r\n    //#region constructor\r\n\r\n    /**\r\n     * @constructs\r\n     * @param {EmitterEventOptions} [options] - The default options for events created by this instance.\r\n     * @param {Emitter} [parentEmitter] - The parent emitter for this instance.\r\n     */\r\n    constructor(options, parentEmitter) {\r\n        this.#emitterEventDefaults = {...this.#emitterEventDefaults, ...options};\r\n        this.#parentEmitter = parentEmitter instanceof Emitter ? parentEmitter : null;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the __events__ read-only property.\r\n     * @type {EmitterEvents}\r\n     * @private\r\n     */\r\n    #events = new Map();\r\n\r\n    /**\r\n     * A map of event types to handler arrays for this instance.\r\n     * @type {EmitterEvents}\r\n     * @readonly\r\n     */\r\n    get __events__(){\r\n        return this.#events;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the __emitterEventDefaults__ read-only property.\r\n     * @type {EmitterEventOptions}\r\n     * @private\r\n     */\r\n    #emitterEventDefaults = {\r\n        bubbles: false,\r\n        cancelable: false\r\n    };\r\n\r\n    /**\r\n     * The default options for events created by this instance. Should be set through the constructor call.\r\n     * @type {EmitterEventOptions}\r\n     * @readonly\r\n     */\r\n    get __emitterEventDefaults__(){\r\n        return this.#emitterEventDefaults;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the __parentEmitter__ read-only property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #parentEmitter = null;\r\n\r\n    /**\r\n     * The parent emitter for this instance.\r\n     * @type {?Emitter}\r\n     * @readonly\r\n     */\r\n    get __parentEmitter__(){\r\n        return this.#parentEmitter;\r\n    }\r\n\r\n    //endregion\r\n\r\n    /**\r\n     * Sets up a function that will be called whenever the specified event is delivered to the target.\r\n     * @param {string} type - A case-sensitive string representing the event type to listen for.\r\n     * @param {EmitterListener} listener - The callback that receives a notification when an event of the specified type occurs.\r\n     * @param {*} [thisArg] - The value of this within the listener.\r\n     */\r\n    #addListener(type, listener, thisArg) {\r\n        if (!isStringNotEmpty(type)) throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        if (!isFunction(listener)) throw new TypeError(\"The 'listener' argument must be a function.\");\r\n        thisArg = thisArg ?? this;\r\n        type.split(\" \").forEach((eventType) => {\r\n            if (!isStringNotEmpty(eventType)) return;\r\n            const parsed = Emitter.parseType(eventType, true);\r\n            let namespaces = this.#events.get(parsed.type);\r\n            if (!namespaces) this.#events.set(parsed.type, (namespaces = new Map()));\r\n            let listeners = namespaces.get(parsed.namespace);\r\n            if (!listeners) namespaces.set(parsed.namespace, (listeners = new Map()));\r\n            let thisArgs = listeners.get(listener);\r\n            if (!thisArgs) listeners.set(listener, (thisArgs = new Set()));\r\n            thisArgs.add(thisArg);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes an event listener previously registered with Emitter.addEmitterListener\r\n     * @param {string} type - A string which specifies the type of event for which to remove an event listener.\r\n     * @param {EmitterListener} [listener] - The listener of the event handler to remove. If not supplied all listeners for the event type are removed.\r\n     * @param {*} [thisArg] - The thisArg value of the event handler to remove. If not supplied all listeners that match the listener and event type are removed.\r\n     */\r\n    #removeListener(type, listener, thisArg) {\r\n        if (!isStringNotEmpty(type)) throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        thisArg = thisArg ?? this;\r\n        type.split(\" \").forEach((eventType) => {\r\n            if (!isStringNotEmpty(eventType)) return;\r\n            const parsed = Emitter.parseType(eventType);\r\n            const types = [];\r\n            if (isStringNotEmpty(parsed.type)) {\r\n                types.push(parsed.type);\r\n            } else if (isStringNotEmpty(parsed.namespace)) {\r\n                for (const [type, namespaces] of this.#events){\r\n                    if (!namespaces.has(parsed.namespace)) continue;\r\n                    types.push(type);\r\n                }\r\n            }\r\n            types.forEach((type) => {\r\n                // a type was provided but doesn't exist so do nothing\r\n                if (!this.#events.has(type)) return;\r\n                const namespaces = this.#events.get(type);\r\n                // a namespace was provided but doesn't exist so do nothing\r\n                if (!namespaces.has(parsed.namespace)) return;\r\n                if (isFunction(listener)){\r\n                    const listeners = namespaces.get(parsed.namespace);\r\n                    // a listener was provided but doesn't exist so do nothing\r\n                    if (!listeners.has(listener)) return;\r\n                    if (!isUndefined(thisArg)){\r\n                        const thisArgs = listeners.get(listener);\r\n                        // a thisArg was provided but doesn't exist so do nothing\r\n                        if (!thisArgs.has(thisArg)) return;\r\n                        // remove just the specified thisArg for the type, namespace & listener\r\n                        thisArgs.delete(thisArg);\r\n                        // if the last thisArg was removed then remove the listener\r\n                        if (thisArgs.size === 0) listeners.delete(listener);\r\n                    } else {\r\n                        // no thisArg was provided so just remove the entire listener for the type & namespace\r\n                        listeners.delete(listener);\r\n                    }\r\n                    // if the last listener was removed then remove the namespace\r\n                    if (listeners.size === 0) namespaces.delete(parsed.namespace);\r\n                } else {\r\n                    // no listener was provided so remove all listeners for the type & namespace\r\n                    namespaces.delete(parsed.namespace);\r\n                }\r\n                // if the last namespace was removed then remove the type\r\n                if (namespaces.size === 0) this.#events.delete(type);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The callback executed for each event type and listener parsed from the arguments.\r\n     * @callback forListener~callback\r\n     * @param {string} type\r\n     * @param {EmitterListener} listener\r\n     * @param {*} thisArg\r\n     * @this {Emitter}\r\n     */\r\n    /**\r\n     * Parse and iterate over the arguments supplied to the .on() and .off() methods.\r\n     * @param {IArguments} args\r\n     * @param {forListener~callback} callback\r\n     * @param {*} [thisArg] - The initial value of the thisArg.\r\n     * @private\r\n     */\r\n    #forListener(args, callback, thisArg){\r\n        if (args.length >= 2 && isStringNotEmpty(args[0]) && isFunction(args[1])) {\r\n            // dealing with (type, listener) OR (type, listener, thisArg)\r\n            if (args.length === 3) thisArg = args[2];\r\n            callback.call(this, args[0], args[1], thisArg);\r\n        } else if (args.length >= 1 && isPlainObject(args[0])) {\r\n            // dealing with (EmitterMap) OR (EmitterMap, thisArg)\r\n            if (args.length === 2) thisArg = args[1];\r\n            objForEach(args[0], (type, listener) => {\r\n                callback.call(this, type, listener, thisArg);\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add event listeners to this instance.\r\n     * @param {string|EmitterMap} typeOrTypeMap - A event type string or an object map of event type keys to listener values.\r\n     * @param {EmitterListener|*} [typeListenerOrTypeMapThisArg] - If the first parameter is a string, this should be a listener function. If the first parameter is an object, this is the thisArg to bind all listeners with.\r\n     * @param {*} [typeThisArg] - If the first parameter is a string and the second a listener, this is the thisArg to bind the listener with.\r\n     * @returns {this}\r\n     */\r\n    on(typeOrTypeMap, typeListenerOrTypeMapThisArg, typeThisArg){\r\n        return this.#forListener(arguments, this.#addListener);\r\n    }\r\n\r\n    /**\r\n     * Remove event listeners from this instance.\r\n     * @param {string|EmitterMap} typeOrTypeMap - A event type string or an object map of event type keys to listener values.\r\n     * @param {EmitterListener|*} [typeListenerOrTypeMapThisArg] - If the first parameter is a string, this should be a listener function. If the first parameter is an object, this is the thisArg to bind all listeners with.\r\n     * @param {*} [typeThisArg] - If the first parameter is a string and the second a listener, this is the thisArg to bind the listener with.\r\n     * @returns {this}\r\n     */\r\n    off(typeOrTypeMap, typeListenerOrTypeMapThisArg, typeThisArg){\r\n        return this.#forListener(arguments, this.#removeListener);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {...*} [args]\r\n     * @returns {boolean} Returns true if defaultPrevented was not called.\r\n     */\r\n    emit(event, ...args) {\r\n        if (event instanceof EmitterEvent) {\r\n            if (event.target === null) event.target = this;\r\n            if (event.currenTarget !== this) event.currenTarget = this;\r\n            const emit = (namespaces) => {\r\n                if (!namespaces.has(event.namespace)) return;\r\n                const listeners = namespaces.get(event.namespace);\r\n                for (const [listener, thisArgs] of listeners) {\r\n                    for (const thisArg of thisArgs) {\r\n                        listener.call(thisArg, event, ...args);\r\n                    }\r\n                }\r\n            };\r\n            if (this.#events.has(event.type)) {\r\n                emit(this.#events.get(event.type));\r\n            }\r\n            if (this.#events.has(\"*\")) {\r\n                emit(this.#events.get(\"*\"));\r\n            }\r\n            if (event.bubbles && !event.isPropagationStopped() && this.#parentEmitter instanceof Emitter) {\r\n                return this.#parentEmitter.emit(event, ...args);\r\n            }\r\n            return !event.isDefaultPrevented();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} event\r\n     * @param {Array} [args]\r\n     * @param {EmitterEventOptions} [options]\r\n     * @returns {boolean}\r\n     */\r\n    trigger(event, args, options) {\r\n        if (!isStringNotEmpty(event)) return false;\r\n        args = Array.isArray(args) ? args : [];\r\n        options = defaults(options, this.#emitterEventDefaults);\r\n        return event.split(\" \")\r\n            .map((type) => this.emit(new EmitterEvent(type, options, this), ...args))\r\n            .every((success) => success);\r\n    }\r\n}\r\n\r\nexport default Emitter;","const arrow = (color, indent = 0) => `color: ${color}; text-indent:${(0.4 * 4) * indent}em; padding: 0.4em; margin-right: 0.4em;`;\r\nconst style = (color, backgroundColor) => `display: inline-block; color: ${color}; background-color: ${backgroundColor}; border-radius: 3px; padding: 0.4em; margin-right: 0.4em;`;\r\nconst diff = (start, end) => {\r\n    const value = end - start,\r\n        color = value > 50 ? \"red\" : (value > 25 ? \"darkorange\" : \"green\");\r\n    return { value, color };\r\n};\r\n\r\nexport default function start(name){\r\n    const startTime = performance.now();\r\n    const startFormat = `%c-->%c${name}`;\r\n    console.debug(startFormat, arrow('green'), style(\"gray\", \"white\"));\r\n    return {\r\n        end: () => {\r\n            const duration = diff(startTime, performance.now());\r\n            const endFormat = `%c<--%c${name}%c${duration.value.toFixed(2)}ms`;\r\n            console.debug(endFormat, arrow('red'), style(\"gray\", \"white\"), style(\"white\", duration.color));\r\n        }\r\n    };\r\n};","import {isStringNotEmpty} from \"../../../../utils/is\";\r\n\r\nexport default {\r\n    __types__: [\"image\",\"iframe\"],\r\n    include: [\".foobox,[data-foobox],[data-foobox-items]\"],\r\n    exclude: [\".nolightbox\"],\r\n    defaultProperties: [{\r\n        name: \"url\",\r\n        obj: [\"url\",\"href\"],\r\n        elem: [\"data:href\",\"data:url\",\"href\"],\r\n        required: true,\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"title\",\r\n        obj: [\"title\"],\r\n        elem: [\"data:title\", \"title\", \"img/title\"],\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"description\",\r\n        obj: [\"description\"],\r\n        elem: [\"data:description\", \"img/alt\"],\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"width\",\r\n        obj: [\"width\"],\r\n        elem: [\"data:width\"]\r\n    },{\r\n        name: \"height\",\r\n        obj: [\"height\"],\r\n        elem: [\"data:height\"]\r\n    },{\r\n        name: \"aspectRatio\",\r\n        obj: [\"aspectRatio\"],\r\n        elem: [\"data:aspectRatio\"]\r\n    }],\r\n    image: {\r\n        priority: 10,\r\n        include: [\r\n            \"[href^='http'][href*='.svg']\",\r\n            \"[href^='http'][href*='.png']\",\r\n            \"[href^='http'][href*='.jpg']\",\r\n            \"[href^='http'][href*='.jpeg']\",\r\n            \"[href^='http'][href*='.webp']\",\r\n            \"[href^='http'][href*='.gif']\",\r\n            \"[href^='http'][href*='.bmp']\",\r\n            \"[href^='http'][href*='fakeimg.pl']\",\r\n            \"[href^='http'].foobox-image\"\r\n        ],\r\n        exclude: []\r\n    },\r\n    iframe: {\r\n        priority: 20,\r\n        include: [\r\n            \"[href^='http'][target='foobox']\",\r\n            \"[href^='http'].foobox-iframe\"\r\n        ],\r\n        exclude: []\r\n    }\r\n};","import defaults from \"./config\"\r\nimport { isStringNotEmpty } from \"../../../../utils/is\";\r\n\r\nexport default {\r\n    ...defaults,\r\n    __types__: [\r\n        ...defaults.__types__,\r\n        \"video\"\r\n    ],\r\n    video: {\r\n        priority: 15,\r\n        include: [\r\n            \"[href^='http'][href*='youtube.com/watch']\",\r\n            \"[href^='http'][href*='youtube.com/v']\",\r\n            \"[href^='http'][href*='youtube.com/embed']\",\r\n            \"[href^='http'][href*='youtube-nocookie.com/watch']\",\r\n            \"[href^='http'][href*='youtube-nocookie.com/v']\",\r\n            \"[href^='http'][href*='youtube-nocookie.com/embed']\",\r\n            \"[href^='http'][href*='youtu.be/']\",\r\n            \"[href^='http'][href*='vimeo.com/']:not([href*='vimeo.com/user'])\",\r\n            \"[href^='http'][href*='.mp4']\",\r\n            \"[href^='http'][href*='.ogv']\",\r\n            \"[href^='http'][href*='.wmv']\",\r\n            \"[href^='http'][href*='.webm']\"\r\n        ],\r\n        properties: [{\r\n            name: \"cover\",\r\n            obj: [\"cover\"],\r\n            elem: [\"data:cover\"],\r\n            test: isStringNotEmpty\r\n        }]\r\n    }\r\n};","import defaults from \"../Parser/config.pro\";\r\n\r\nexport default {\r\n    ...defaults,\r\n    include: []\r\n};","import {isStringNotEmpty} from \"./is\";\r\n\r\n/**\r\n * If the value is a string it is returned, if it's a string array the values are joined using a comma, otherwise null is returned.\r\n * @param {*} value\r\n * @returns {?string}\r\n */\r\nfunction makeSelector(value){\r\n    if (isStringNotEmpty(value)) {\r\n        return value;\r\n    }\r\n    if (Array.isArray(value) && value.length) {\r\n        const result = value.filter((val) => isStringNotEmpty(val)).join(\",\");\r\n        return isStringNotEmpty(result) ? result : null;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport default makeSelector;","/**\r\n * A simple class containing the results of a parsed item.\r\n */\r\nclass Item {\r\n    /**\r\n     * A reference to the parent container this item belongs to.\r\n     */\r\n    parent;\r\n\r\n    /**\r\n     * A reference to the type parser that produced this item.\r\n     * @type {TypeParser}\r\n     */\r\n    type;\r\n\r\n    /**\r\n     * The reference object parsed.\r\n     * @type {*}\r\n     */\r\n    ref;\r\n\r\n    /**\r\n     * An object containing all required properties for the item.\r\n     * @type {object}\r\n     */\r\n    requiredProperties;\r\n\r\n    /**\r\n     * @type {?EventTarget}\r\n     * @private\r\n     */\r\n    #triggerTarget = null;\r\n\r\n    /**\r\n     * Create a new instance of the ParserItem class.\r\n     * @param {Container} parent - A reference to the parent container this item belongs to.\r\n     * @param {TypeParser} type - A reference to the type parser that produced this item.\r\n     * @param {*} ref - The reference object parsed.\r\n     * @param {?EventTarget} [triggerTarget] - The EventTarget instance that triggers this item.\r\n     */\r\n    constructor(parent, type, ref, triggerTarget) {\r\n        this.parent = parent;\r\n        this.type = type;\r\n        this.ref = ref;\r\n        if (triggerTarget instanceof EventTarget){\r\n            this.#triggerTarget = triggerTarget;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The EventTarget instance that triggers this item.\r\n     * @returns {?EventTarget}\r\n     */\r\n    get triggerTarget(){\r\n        return this.#triggerTarget;\r\n    }\r\n\r\n    /**\r\n     * @param {EventTarget} value - The EventTarget instance to use as the trigger.\r\n     */\r\n    set triggerTarget(value){\r\n        if (value instanceof EventTarget){\r\n            this.#triggerTarget = value;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The Item.trigger property must be an instance of EventTarget!\");\r\n    }\r\n\r\n    /**\r\n     * Get all properties for this item.\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {object}\r\n     */\r\n    getProperties(nocache){\r\n        const properties = this.type.getProperties(this.ref, nocache);\r\n        return { ...properties, type: this.type.name };\r\n    }\r\n}\r\n\r\nexport default Item;","import {isFunction, isPlainObject, isStringNotEmpty} from \"../../../../../../utils/is\";\r\nimport mergeArray from \"../../../../../../utils/mergeArray\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback PropertyParser~ctor\r\n * @param {TypeParser} parent\r\n * @param {PropertyParser~Configuration} configuration\r\n * @returns {PropertyParser}\r\n */\r\n/**\r\n * @typedef {object} PropertyParserDefinition\r\n * @property {PropertyParser~Configuration} configuration\r\n * @property {PropertyParser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default property parser is registered using the new name. If an array, the first element is the name, the second is the custom property parser constructor.\r\n * @typedef {PropertyParser~Configuration|[PropertyParser~Configuration,PropertyParser~ctor]} propertyParserDefinition\r\n */\r\n/**\r\n * A method used to test the parsed value to check if it is valid.\r\n * @callback PropertyParser~test\r\n * @param {*} value\r\n * @param {PropertyParser} [propertyParser]\r\n * @returns {boolean}\r\n */\r\n/**\r\n * A method used to convert the parsed value to a specific type.\r\n * @callback PropertyParser~convert\r\n * @param {*} value\r\n * @param {PropertyParser} [propertyParser]\r\n * @returns {*}\r\n */\r\n/**\r\n * The configuration for parsing a property from an object.\r\n * @typedef {object} PropertyParser~Configuration\r\n * @property {string} name - The name of the property as it appears in the resulting properties object.\r\n * @property {boolean} [required=false] - Whether or not this property is required. If set to true and the parsed value is null, undefined or the same as the defaultValue the item will fail to parse.\r\n * @property {boolean} [tracked=false] - Whether or not changes to this property are tracked. By default all required properties are tracked and will ignore this value.\r\n * @property {*} [defaultValue=null] - The default value returned for this property if none is parsed.\r\n * @property {PropertyParser~test} [test] - A method used to test the parsed value to check if it is valid. If not supplied the value is considered valid if: value != null && value !== defaultValue\r\n * @property {PropertyParser~convert} [convert] - A method used to convert the parsed value to a specific type.\r\n * @property {string} [queryParent=\"^\"]\r\n * @property {string} [queryPath=\"/\"]\r\n * @property {string} [queryType=\":\"]\r\n * @property {string[]} [obj=[]] - An array of queries used to parse a plain object reference for the property value. The properties are iterated in index order and the first match is returned.\r\n * @property {string[]} [elem=[]] - An array of queries used to parse an HTMLElement reference for the property value. The queries are iterated in index order and the first match is returned.\r\n */\r\n\r\n\r\n//endregion\r\n\r\nclass PropertyParser {\r\n\r\n    //#region static\r\n\r\n    /**\r\n     * The default convert method used by all properties. This does nothing but pass through the supplied value.\r\n     * @param {*} value - The parsed value.\r\n     * @param {PropertyParser} property - The property object itself.\r\n     * @returns {*}\r\n     */\r\n    static DEFAULT_CONVERT(value, property){\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * The default test method used by all properties to determine if the parsed value is valid.\r\n     * @param {*} value - The parsed value.\r\n     * @param {PropertyParser} property - The property object itself.\r\n     * @returns {boolean}\r\n     */\r\n    static DEFAULT_TEST(value, property){\r\n        return value != null && value !== property.defaultValue;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {propertyParserDefinition} configuration\r\n     * @returns {?PropertyParserDefinition}\r\n     */\r\n    static DEFINITION(configuration){\r\n        if (isPlainObject(configuration)){\r\n            return { configuration: /** @type PropertyParser~Configuration */ configuration, ctor: /** @type PropertyParser~ctor */ PropertyParser };\r\n        }\r\n        if (Array.isArray(configuration) && configuration.length === 2 && isPlainObject(configuration[0]) && isFunction(configuration[1])){\r\n            return { configuration: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Merges all property definitions from the source into the target, properties are compared by name.\r\n     * @param {propertyParserDefinition[]} target - The target array to push definitions into.\r\n     * @param {propertyParserDefinition[]} source - The source array to pull definitions from.\r\n     * @returns {propertyParserDefinition[]}\r\n     */\r\n    static MERGE_DEFINITIONS(target, source){\r\n        return mergeArray(target, source, (targetDefinition, sourceDefinition) => {\r\n            const targetDef = PropertyParser.DEFINITION(targetDefinition),\r\n                sourceDef = PropertyParser.DEFINITION(sourceDefinition);\r\n            if (!targetDef || !sourceDef) return false;\r\n            return targetDef.configuration.name === sourceDef.configuration.name;\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {TypeParser} typeParser\r\n     * @param {propertyParserDefinition} definition\r\n     * @returns {?PropertyParser}\r\n     */\r\n    static create(typeParser, definition){\r\n        const def = PropertyParser.DEFINITION(definition);\r\n        return def ? new def.ctor(typeParser, def.configuration) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {TypeParser} typeParser\r\n     * @param {propertyParserDefinition[]} propertyParserDefinitions\r\n     * @returns {PropertyParser[]}\r\n     */\r\n    static createAll(typeParser, propertyParserDefinitions){\r\n        return propertyParserDefinitions.reduce((result, definition) => {\r\n            const propertyParser = PropertyParser.create(typeParser, definition);\r\n            if (propertyParser) result.push(propertyParser);\r\n            return result;\r\n        },/** @type {PropertyParser[]} */ []);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} ref\r\n     * @param {PropertyParser[]} properties\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {?object}\r\n     */\r\n    static getValues(ref, properties, nocache){\r\n        const result = {};\r\n        for (const property of properties){\r\n            const value = property.getValue(ref, nocache);\r\n            if (property.required && !property.test(value)){\r\n                // if there is a required property that is not supplied then stop parsing and exit early\r\n                return null;\r\n            } else {\r\n                result[property.name] = value;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of a PropertyParser.\r\n     * @param {TypeParser} typeParser - The parent type parser for this instance.\r\n     * @param {PropertyParser~Configuration} configuration - The configuration for this instance.\r\n     */\r\n    constructor(typeParser, configuration) {\r\n        this.#typeParser = typeParser;\r\n        this.#name = configuration.name;\r\n        this.required = configuration.required ?? false;\r\n        this.defaultValue = configuration.defaultValue ?? null;\r\n        this.#convert = configuration.convert ?? PropertyParser.DEFAULT_CONVERT;\r\n        this.#test = configuration.test ?? PropertyParser.DEFAULT_TEST;\r\n        this.queryParent = configuration.queryParent ?? \"^\";\r\n        this.queryPath = configuration.queryPath ?? \"/\";\r\n        this.queryType = configuration.queryType ?? \":\";\r\n        if (Array.isArray(configuration.obj)){\r\n            this.obj = configuration.obj.map((query) => this.objectQuery(query)).filter((query) => query != null);\r\n        }\r\n        if (Array.isArray(configuration.elem)){\r\n            this.elem = configuration.elem.map((query) => this.elementQuery(query)).filter((query) => query != null);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region properties\r\n\r\n    /**\r\n     * The private field used by the 'typeParser' read-only property.\r\n     * @type {TypeParser}\r\n     * @private\r\n     */\r\n    #typeParser;\r\n    /**\r\n     * Get the parent type parser.\r\n     * @type {TypeParser}\r\n     * @readonly\r\n     */\r\n    get typeParser(){\r\n        return this.#typeParser;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the property was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Whether or not this property is required.\r\n     * @type {boolean}\r\n     * @default false\r\n     */\r\n    required;\r\n    /**\r\n     * The default value returned if none is parsed.\r\n     * @type {*}\r\n     * @default null\r\n     */\r\n    defaultValue;\r\n    /**\r\n     * The delimiter used by element queries to target a parent element.\r\n     * @type {string}\r\n     * @default \"^\"\r\n     */\r\n    queryParent;\r\n    /**\r\n     * The delimiter used by queries to target either a child element or object property.\r\n     * @type {string}\r\n     * @default \"/\"\r\n     */\r\n    queryPath;\r\n    /**\r\n     * The delimiter used by element queries to specify where the value should be pulled from.\r\n     * @type {string}\r\n     * @default \":\"\r\n     */\r\n    queryType;\r\n    /**\r\n     * An array of compiled queries used to interrogate plain objects.\r\n     * @type {ObjectQuery[]}\r\n     */\r\n    obj = [];\r\n    /**\r\n     * An array of compiled queries used to interrogate elements.\r\n     * @type {ElementQuery[]}\r\n     */\r\n    elem = [];\r\n    /**\r\n     * The method used to convert the parsed value to another type.\r\n     * @type {PropertyParser~convert}\r\n     * @default Property.DEFAULT_CONVERT\r\n     */\r\n    #convert;\r\n    /**\r\n     * The method used to test if the parsed value is valid.\r\n     * @type {PropertyParser~test}\r\n     * @default Property.DEFAULT_CONVERT\r\n     */\r\n    #test;\r\n    /**\r\n     *\r\n     * @type {Map<string, *>}\r\n     */\r\n    #cache = new Map();\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * @typedef {object} PropertyQuery\r\n     * @property {string} raw\r\n     * @property {string} name\r\n     * @property {function(*):*} getValue\r\n     */\r\n\r\n    /**\r\n     *\r\n     * @param {string} query\r\n     * @returns {?ObjectQuery}\r\n     */\r\n    objectQuery(query){\r\n        /**\r\n         * @typedef {PropertyQuery} ObjectQuery\r\n         * @property {string[]} path\r\n         */\r\n        if (isStringNotEmpty(query)){\r\n            let name = query, path = [];\r\n            if (name.indexOf(this.queryPath) !== -1){\r\n                const parts = name.split(this.queryPath);\r\n                name = parts.pop();\r\n                path.push(parts);\r\n            }\r\n            const target = (ref) => {\r\n                let result = ref;\r\n                for (const part of path){\r\n                    result = result[part];\r\n                    if (!result) break;\r\n                }\r\n                return result ?? null;\r\n            };\r\n            return {\r\n                raw: query,\r\n                name,\r\n                path,\r\n                getValue: (ref) => {\r\n                    const targetRef = target(ref);\r\n                    if (targetRef){\r\n                        return this.convert(targetRef[name]) ?? this.defaultValue;\r\n                    }\r\n                    return this.defaultValue;\r\n                }\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} query\r\n     * @returns {?ElementQuery}\r\n     */\r\n    elementQuery(query){\r\n        /**\r\n         * @typedef {PropertyQuery} ElementQuery\r\n         * @property {number} parents\r\n         * @property {?string} selector\r\n         */\r\n        if (isStringNotEmpty(query)){\r\n            let name = query, parents = 0, selector = null, type = \"prop\";\r\n            while(name[0] === this.queryParent){\r\n                parents++;\r\n                name = name.slice(1);\r\n            }\r\n            if (name.indexOf(this.queryPath) !== -1){\r\n                const parts = name.split(this.queryPath);\r\n                selector = parts[0];\r\n                name = parts[1];\r\n            }\r\n            if (name.indexOf(this.queryType) !== -1){\r\n                const parts = name.split(this.queryType);\r\n                type = parts[0];\r\n                name = parts[1];\r\n            }\r\n            const target = (ref) => {\r\n                let result = ref;\r\n                for (let i = 0; i < parents; i++){\r\n                    result = result.parentElement;\r\n                    if (!result) break;\r\n                }\r\n                return result && selector ? result.querySelector(selector) : result;\r\n            };\r\n            let getValue;\r\n            switch (type){\r\n                case \"prop\":\r\n                    getValue = (ref) => { return this.convert(ref[name]) ?? this.defaultValue; };\r\n                    break;\r\n                case \"data\":\r\n                    getValue = (ref) => { return this.convert(ref.dataset[name]) ?? this.defaultValue; };\r\n                    break;\r\n                case \"attr\":\r\n                    getValue = (ref) => { return ref.hasAttribute(name) ? this.convert(ref.getAttribute(name)) : this.defaultValue; };\r\n                    break;\r\n                default:\r\n                    getValue = () => this.defaultValue;\r\n                    break;\r\n            }\r\n            return {\r\n                raw: query,\r\n                name,\r\n                type,\r\n                parents,\r\n                selector,\r\n                getValue: (ref) => {\r\n                    const targetRef = target(ref);\r\n                    if (targetRef){\r\n                        return getValue(targetRef);\r\n                    }\r\n                    return this.defaultValue;\r\n                }\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param ref\r\n     * @param nocache\r\n     * @returns {*}\r\n     */\r\n    getValue(ref, nocache){\r\n        if (!nocache && this.#cache.has(ref)){\r\n            return this.#cache.get(ref);\r\n        }\r\n        let result = this.defaultValue;\r\n        if (ref instanceof HTMLElement){\r\n            for (const query of this.elem){\r\n                const value = query.getValue(ref);\r\n                if (this.test(value)){\r\n                    result = value;\r\n                    break;\r\n                }\r\n            }\r\n        } else if (isPlainObject(ref)){\r\n            for (const query of this.obj){\r\n                const value = query.getValue(ref);\r\n                if (this.test(value)){\r\n                    result = value;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.#cache.set(ref, result);\r\n        return result;\r\n    }\r\n\r\n    convert(value){\r\n        return this.#convert(value, this);\r\n    }\r\n\r\n    test(value){\r\n        return this.#test(value, this);\r\n    }\r\n}\r\n\r\nexport default PropertyParser;","import {isFunction} from \"./is\";\r\n\r\n/**\r\n * @template T\r\n * @param {Array<T>} target\r\n * @param {Array<T>} source\r\n * @param {function(T, T):boolean} [equalityComparer]\r\n * @returns {Array<T>}\r\n */\r\nfunction mergeArray(target, source, equalityComparer){\r\n    if (isFunction(equalityComparer)){\r\n        return [...target, ...source.filter((sourceValue) => !target.some((targetValue) => equalityComparer(targetValue, sourceValue)))];\r\n    }\r\n    return [...target, ...source.filter((targetValue) => !target.includes(targetValue))];\r\n}\r\n\r\nexport default mergeArray;","import {isFunction, isPlainObject, isStringNotEmpty} from \"../../../../../utils/is\";\r\nimport {defaults} from \"../../../../../utils/object\";\r\nimport makeSelector from \"../../../../../utils/makeSelector\";\r\nimport Item from \"../../Container/Item\";\r\nimport PropertyParser from \"./PropertyParser\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback TypeParser~ctor\r\n * @param {Parser} parser\r\n * @param {string} name\r\n * @returns TypeParser\r\n */\r\n/**\r\n * @typedef {object} TypeParserDefinition\r\n * @property {string} name\r\n * @property {TypeParser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default type parser is registered using the new name. If an array, the first element is the name, the second is the custom type parser constructor.\r\n * @typedef {string|[string,TypeParser~ctor]} typeParserDefinition\r\n */\r\n/**\r\n * The configuration for parsing an item from an object.\r\n * @typedef {object} TypeParser~Configuration\r\n * @property {number} [priority=0]\r\n * @property {string[]} [include]\r\n * @property {string[]} [exclude]\r\n * @property {propertyParserDefinition[]} [properties]\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Parses item data from various sources depending on configuration.\r\n */\r\nclass TypeParser {\r\n\r\n    //region static\r\n\r\n    /**\r\n     *\r\n     * @param {typeParserDefinition} configuration\r\n     * @returns {?TypeParserDefinition}\r\n     */\r\n    static DEFINITION(configuration){\r\n        if (isStringNotEmpty(configuration)){\r\n            return { name: /** @type string */ configuration, ctor: /** @type TypeParser~ctor */ TypeParser };\r\n        }\r\n        if (Array.isArray(configuration) && configuration.length === 2 && isStringNotEmpty(configuration[0]) && isFunction(configuration[1])){\r\n            return { name: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Parser} parser\r\n     * @param {typeParserDefinition} definition\r\n     * @returns {?TypeParser}\r\n     */\r\n    static create(parser, definition){\r\n        const def = TypeParser.DEFINITION(definition);\r\n        return def ? new def.ctor(parser, def.name) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Parser} parser\r\n     * @param {typeParserDefinition[]} typeParserDefinitions\r\n     * @returns {TypeParser[]}\r\n     */\r\n    static createAll(parser, typeParserDefinitions){\r\n        return typeParserDefinitions.reduce((result, config) => {\r\n            const typeParser = TypeParser.create(parser, config);\r\n            if (typeParser) result.push(typeParser);\r\n            return result;\r\n        },/** @type {TypeParser[]} */ []).sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Parses item data from various sources depending on configuration.\r\n     * @param {Parser} parser - The parent parser for this instance.\r\n     * @param {string} name - The type of item parsed by this instance.\r\n     */\r\n    constructor(parser, name) {\r\n        this.#parser = parser;\r\n        this.#name = name;\r\n        defaults(this.config, this.defaults);\r\n        this.#includeSelector = makeSelector(this.config.include);\r\n        this.#excludeSelector = makeSelector(this.config.exclude);\r\n        this.#properties = PropertyParser.createAll(this, PropertyParser.MERGE_DEFINITIONS(this.config.properties, this.parser.config.defaultProperties));\r\n        this.#requiredProperties = this.properties.filter((property) => property.required);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'parent' read-only property.\r\n     * @type {Parser}\r\n     * @private\r\n     */\r\n    #parser;\r\n    /**\r\n     * Get the parent parser.\r\n     * @type {Parser}\r\n     * @readonly\r\n     */\r\n    get parser(){\r\n        return this.#parser;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the type parser was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Get the default type parser configuration.\r\n     * @type {TypeParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get defaults(){\r\n        return {\r\n            priority: 0,\r\n            include: [],\r\n            exclude: [],\r\n            properties: [],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the parser configuration.\r\n     * @type {TypeParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if (isPlainObject(this.parser.config[this.name])){\r\n            return this.parser.config[this.name];\r\n        }\r\n        return this.parser.config[this.name] = {};\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'priority' read-only property.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    #priority;\r\n    /**\r\n     * Get the priority.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    get priority(){\r\n        return this.#priority;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'includeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #includeSelector;\r\n    /**\r\n     * Get the result of combining all configured include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get includeSelector(){\r\n        return this.#includeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'excludeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #excludeSelector;\r\n    /**\r\n     * Get the result of combining all configured exclude selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get excludeSelector(){\r\n        return this.#excludeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'properties' read-only property.\r\n     * @type {PropertyParser[]}\r\n     * @private\r\n     */\r\n    #properties;\r\n    /**\r\n     * Get all configured property parsers.\r\n     * @type {PropertyParser[]}\r\n     * @readonly\r\n     */\r\n    get properties(){\r\n        return this.#properties;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'requiredProperties' read-only property.\r\n     * @type {PropertyParser[]}\r\n     * @private\r\n     */\r\n    #requiredProperties;\r\n    /**\r\n     * Get all configured required property parsers.\r\n     * @type {PropertyParser[]}\r\n     * @readonly\r\n     */\r\n    get requiredProperties(){\r\n        return this.#requiredProperties;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Item>}\r\n     */\r\n    #cache = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #requiredPropertyCache = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #propertyCache = new Map();\r\n\r\n    //endregion\r\n\r\n    /**\r\n     * Checks if the supplied reference is included by this instance.\r\n     * NOTE: This DOES NOT check for exclusions! Use the canParse method if you want to check if a reference is both included AND NOT excluded.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    includes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.includeSelector !== null && ref.matches(this.includeSelector);\r\n        }\r\n        if (isPlainObject(ref)){\r\n            return ref.type === this.name;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference is excluded by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    excludes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.excludeSelector !== null && ref.matches(this.excludeSelector);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference can be parsed by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    canParse(ref) {\r\n        return this.includes(ref) && !this.excludes(ref);\r\n    }\r\n\r\n    create(parent, ref, trigger){\r\n        if (ref instanceof HTMLElement || isPlainObject(ref)){\r\n            return new Item(parent, this, ref, trigger);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new ParserItem.\r\n     * @param {Container} parent - The parent container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - Whether or not to ignore any cached values when parsing the item.\r\n     * @returns {?Item} Returns null if parsing fails.\r\n     */\r\n    parse(parent, ref, nocache){\r\n        let item;\r\n        if (this.#cache.has(ref)){\r\n            item = this.#cache.get(ref);\r\n        } else {\r\n            item = this.create(parent, ref, this.getTrigger(ref));\r\n        }\r\n        if (item instanceof Item){\r\n            const properties = this.getRequiredProperties(ref, nocache);\r\n            if (!properties){\r\n                this.#cache.delete(ref);\r\n                return null;\r\n            }\r\n            item.requiredProperties = properties;\r\n            this.#cache.set(ref, item);\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n     * Gets the trigger element for the reference object. Trigger elements are used to open the modal.\r\n     * @param {*} ref - The reference object to get the trigger from.\r\n     * @returns {?HTMLElement} Returns null if the item has no trigger element.\r\n     */\r\n    getTrigger(ref){\r\n        return ref instanceof HTMLElement ? ref : null;\r\n    }\r\n\r\n    getRequiredProperties(ref, nocache){\r\n        if (!nocache && this.#requiredPropertyCache.has(ref)){\r\n            return this.#requiredPropertyCache.get(ref);\r\n        }\r\n        const properties = PropertyParser.getValues(ref, this.requiredProperties, nocache);\r\n        this.#requiredPropertyCache.set(ref, properties);\r\n        return properties;\r\n    }\r\n\r\n    getProperties(ref, nocache){\r\n        if (!nocache && this.#propertyCache.has(ref)){\r\n            return this.#propertyCache.get(ref);\r\n        }\r\n        const properties = PropertyParser.getValues(ref, this.properties, nocache);\r\n        this.#propertyCache.set(ref, properties);\r\n        return properties;\r\n    }\r\n}\r\n\r\nexport default TypeParser;","import {extend} from \"../../../../utils/object\";\r\nimport {isNumber} from \"../../../../utils/is\";\r\n\r\n/**\r\n * A simple class containing the results of parsing a reference object.\r\n */\r\nclass Container {\r\n\r\n    /**\r\n     * A reference to the parser that produced this result.\r\n     * @type {Parser}\r\n     */\r\n    parser;\r\n\r\n    /**\r\n     * The reference object parsed.\r\n     * @type {*}\r\n     */\r\n    ref;\r\n\r\n    /**\r\n     * An object containing any parsed options.\r\n     * @type {object}\r\n     */\r\n    options;\r\n\r\n    /**\r\n     * @type {?EventTarget}\r\n     * @private\r\n     */\r\n    #triggerTarget = null;\r\n\r\n    /**\r\n     * An array of all parsed items.\r\n     * @type {Item[]}\r\n     */\r\n    items = [];\r\n\r\n    /**\r\n     * Create a new instance of the Container class.\r\n     * @param {Parser} parser - A reference to the parser that produced this container.\r\n     * @param {*} ref - The reference object parsed.\r\n     * @param {object} [options] - An object containing any parsed options.\r\n     * @param {?EventTarget} [triggerTarget] - The EventTarget instance that triggers the modal.\r\n     */\r\n    constructor(parser, ref, options, triggerTarget) {\r\n        this.parser = parser;\r\n        this.ref = ref;\r\n        this.options = extend({}, options);\r\n        if (triggerTarget instanceof EventTarget){\r\n            this.#triggerTarget = triggerTarget;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The EventTarget instance that triggers the modal.\r\n     * @returns {?EventTarget}\r\n     */\r\n    get triggerTarget(){\r\n        return this.#triggerTarget;\r\n    }\r\n\r\n    /**\r\n     * @param {EventTarget} value - The EventTarget instance to use as the trigger.\r\n     */\r\n    set triggerTarget(value){\r\n        if (value instanceof EventTarget){\r\n            this.#triggerTarget = value;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The Container.triggerTarget property must be an instance of EventTarget.\");\r\n    }\r\n\r\n    get firstIndex(){\r\n        return this.items.length ? 0 : -1;\r\n    }\r\n\r\n    get lastIndex(){\r\n        return this.items.length ? this.items.length - 1 : -1;\r\n    }\r\n\r\n    withinRange(index){\r\n        return isNumber(index) && index >= this.firstIndex && index <= this.lastIndex;\r\n    }\r\n\r\n    getByIndex(index){\r\n        return this.withinRange(index) ? this.items[index] : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {?Item}\r\n     */\r\n    getFirst(){\r\n        return this.firstIndex !== -1 ? this.items[this.firstIndex] : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {?Item}\r\n     */\r\n    getLast(){\r\n        return this.lastIndex !== -1 ? this.items[this.lastIndex] : null;\r\n    }\r\n\r\n    getNext(current, allowLoop){\r\n        const index = this.items.indexOf(current);\r\n        if (index !== -1){\r\n            let nextIndex = index + 1;\r\n            const withinRange = this.withinRange(nextIndex);\r\n            if (withinRange){\r\n                return this.items[nextIndex];\r\n            }\r\n            if (!withinRange && allowLoop){\r\n                return this.getFirst();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getPrevious(current, allowLoop){\r\n        const index = this.items.indexOf(current);\r\n        if (index !== -1){\r\n            let previousIndex = index - 1;\r\n            const withinRange = this.withinRange(previousIndex);\r\n            if (withinRange){\r\n                return this.items[previousIndex];\r\n            }\r\n            if (!withinRange && allowLoop){\r\n                return this.getLast();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    get [Symbol.toStringTag]() {\r\n        return \"Container\";\r\n    }\r\n}\r\n\r\nexport default Container;","/**\r\n *\r\n * @param {function} callback\r\n * @param {...*} [args]\r\n * @returns {Promise<*>}\r\n */\r\nasync function doCallback(callback, ...args){\r\n    return new Promise((resolve) => {\r\n        setTimeout(()=>{\r\n            resolve(callback(...args));\r\n        }, 0);\r\n    });\r\n}\r\n\r\n/**\r\n *\r\n * @param callback\r\n */\r\nfunction enqueue(callback){\r\n    setTimeout(callback, 0);\r\n}\r\n\r\n/**\r\n *\r\n * @template T\r\n * @param {Iterable<T>} iterable\r\n * @param {function(T)} callback\r\n * @returns {Promise<void>}\r\n */\r\nasync function asyncForEach(iterable, callback){\r\n    for (const i of iterable){\r\n        await doCallback(callback, i);\r\n    }\r\n}\r\n\r\nexport {\r\n    enqueue,\r\n    asyncForEach\r\n};","import {defaults, objReduce} from \"../../../../utils/object\";\r\nimport {isFunction, isPlainObject, isStringNotEmpty} from \"../../../../utils/is\";\r\nimport makeSelector from \"../../../../utils/makeSelector\";\r\nimport TypeParser from \"./TypeParser\";\r\nimport Container from \"../Container\";\r\nimport Emitter from \"../../../../utils/Emitter\";\r\nimport {asyncForEach} from \"../../../../utils/iasync\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback Parser~ctor\r\n * @param {ContainerController} containers\r\n * @param {string} name\r\n * @returns Parser\r\n */\r\n/**\r\n * @typedef {object} ParserDefinition\r\n * @property {string} name\r\n * @property {Parser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default parser is registered using the new name. If an array, the first element is the name, the second is the custom parser constructor.\r\n * @typedef {string|[string,Parser~ctor]} parserDefinition\r\n */\r\n/**\r\n * @typedef {object} Parser~Configuration\r\n * @property {typeParserDefinition[]} [__types__]\r\n * @property {number} [priority=49]\r\n * @property {string[]} [include]\r\n * @property {string[]} [exclude]\r\n * @property {{options:?string,items:?string}} [data]\r\n * @property {propertyParserDefinition[]} [defaultProperties]\r\n */\r\n/**\r\n * @typedef {object} ParserChange\r\n * @property {Item[]} added\r\n * @property {Item[]} removed\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * The base parser class.\r\n * @class\r\n */\r\nclass Parser extends Emitter {\r\n\r\n    //region static\r\n\r\n    /**\r\n     * @param {parserDefinition} configuration\r\n     * @returns {?ParserDefinition}\r\n     */\r\n    static DEFINITION(configuration){\r\n        if (isStringNotEmpty(configuration)){\r\n            return { name: /** @type string */ configuration, ctor: /** @type Parser~ctor */ Parser };\r\n        }\r\n        if (Array.isArray(configuration) && configuration.length === 2 && isStringNotEmpty(configuration[0]) && isFunction(configuration[1])){\r\n            return { name: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {ContainerController} containers\r\n     * @param {parserDefinition} definition\r\n     * @returns {?Parser}\r\n     */\r\n    static create(containers, definition){\r\n        const def = Parser.DEFINITION(definition);\r\n        return def ? new def.ctor(containers, def.name) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {ContainerController} containers\r\n     * @param {parserDefinition[]} parserDefinitions\r\n     * @returns {Parser[]}\r\n     */\r\n    static createAll(containers, parserDefinitions){\r\n        return parserDefinitions.reduce((result, config) => {\r\n            const parser = Parser.create(containers, config);\r\n            if (parser) result.push(parser);\r\n            return result;\r\n        },/** @type {Parser[]} */ []).sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of the Parser class.\r\n     * @param {ContainerController} containers - The parent for this instance.\r\n     * @param {string} name - The name the parser was registered with.\r\n     */\r\n    constructor(containers, name) {\r\n        super({bubbles: true}, containers);\r\n        this.#containers = containers;\r\n        this.#name = name;\r\n        defaults(this.config, this.defaults);\r\n        this.#priority = this.config.priority;\r\n        this.#includeSelector = makeSelector(this.config.include);\r\n        this.#excludeSelector = makeSelector(this.config.exclude);\r\n        this.#types = TypeParser.createAll(this, this.config.__types__);\r\n        this.#typesSelector = makeSelector(this.#types.map((type) => type.includeSelector));\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'containers' read-only property.\r\n     * @type {ContainerController}\r\n     * @private\r\n     */\r\n    #containers;\r\n    /**\r\n     * Get the containers controller for the parser.\r\n     * @type {ContainerController}\r\n     * @readonly\r\n     */\r\n    get containers(){\r\n        return this.#containers;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the parser was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Get the default parser configuration.\r\n     * @type {Parser~Configuration}\r\n     * @readonly\r\n     */\r\n    get defaults(){\r\n        return {\r\n            __types__: [],\r\n            priority: 49,\r\n            include: [],\r\n            exclude: [],\r\n            data: {\r\n                options: \"foobox\",\r\n                items: \"fooboxItems\",\r\n            },\r\n            defaultProperties: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the parser configuration.\r\n     * @type {Parser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if (isPlainObject(this.containers.config[this.name])){\r\n            return this.containers.config[this.name];\r\n        }\r\n        return this.containers.config[this.name] = {};\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'priority' read-only property.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    #priority;\r\n    /**\r\n     * Get the priority.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    get priority(){\r\n        return this.#priority;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'includeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #includeSelector;\r\n    /**\r\n     * Get the result of combining all configured include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get includeSelector(){\r\n        return this.#includeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'excludeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #excludeSelector;\r\n    /**\r\n     * Get the result of combining all configured exclude selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get excludeSelector(){\r\n        return this.#excludeSelector;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {TypeParser[]}\r\n     */\r\n    #types = [];\r\n\r\n    /**\r\n     * The private field used by the 'typesSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #typesSelector;\r\n    /**\r\n     * Get the result of combining all configured type parser include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get typesSelector(){\r\n        return this.#typesSelector;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Container>}\r\n     */\r\n    #containerCache = new Map();\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #dataCache = new Map();\r\n\r\n    /**\r\n     * Whether or not the parseDocument method should be called.\r\n     * @type {boolean}\r\n     * @readonly\r\n     */\r\n    get isDocumentParser(){ return true; }\r\n\r\n    //endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Checks if the supplied reference is included by this instance.\r\n     * NOTE: This DOES NOT check for exclusions! Use the canParse method if you want to check if a reference is both included AND NOT excluded.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    includes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.includeSelector !== null && ref.matches(this.includeSelector);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference is excluded by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    excludes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.excludeSelector !== null && ref.matches(this.excludeSelector);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference can be parsed by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    canParse(ref){\r\n        return this.includes(ref) && !this.excludes(ref);\r\n    }\r\n\r\n    /**\r\n     * Gets any configured data for an element reference.\r\n     * @param {HTMLElement} ref\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {Object}\r\n     */\r\n    data(ref, nocache){\r\n        if (!nocache && this.#dataCache.has(ref)){\r\n            return this.#dataCache.get(ref);\r\n        }\r\n        const dataConfig = this.config.data;\r\n        const result = objReduce(dataConfig, (result, dataName, key) => {\r\n            if (isStringNotEmpty(dataName) && ref.dataset.hasOwnProperty(dataName)){\r\n                let data;\r\n                try {\r\n                    data = JSON.parse(ref.dataset[dataName]);\r\n                } catch (err) {\r\n                    console.error(`Invalid dataset.${dataName} JSON string supplied.`, ref.dataset, dataName, err);\r\n                    data = null; // cache a null for errors so they will only be triggered again when the cache is flushed\r\n                } finally {\r\n                    result[key] = data;\r\n                }\r\n            } else {\r\n                result[key] = null;\r\n            }\r\n            return result;\r\n        }, {});\r\n        this.#dataCache.set(ref, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Parses the document and returns an array of new Containers.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Promise<Container[]>}\r\n     */\r\n    async parseDocument(handledRefs, nocache){\r\n        const results = [];\r\n        for (const selector of this.config.include){\r\n            await asyncForEach(document.querySelectorAll(selector), (ref) => {\r\n                if (handledRefs.has(ref) || this.excludes(ref)) return;\r\n                const container = this.parse(ref, handledRefs, nocache);\r\n                if (!container) return;\r\n                results.push(container);\r\n                handledRefs.add(ref);\r\n            });\r\n        }\r\n        this.purgeCache(results);\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Purges the internal cache given the results of the last parseDocument call.\r\n     * @param {Container[]} results\r\n     */\r\n    purgeCache(results){\r\n        for (const container of this.#containerCache.values()){\r\n            if (!results.includes(container) || this.shouldPurge(container)){\r\n                this.#containerCache.delete(container.ref);\r\n                this.trigger(\"removed-container\", [container]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a container should be purged from cache.\r\n     * @param {Container} container\r\n     * @returns {boolean}\r\n     */\r\n    shouldPurge(container){\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} ref\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {{itemRefs:Iterable, options:object, trigger:?EventTarget}}\r\n     */\r\n    getArgs(ref, nocache){\r\n        let trigger = null, itemRefs = [], options = {};\r\n        if (ref instanceof HTMLElement){\r\n            const data = this.data(ref, nocache);\r\n            if (isPlainObject(data.options)){\r\n                options = data.options;\r\n            }\r\n            if (Array.isArray(data.items)){\r\n                trigger = ref;\r\n                itemRefs.push(...data.items);\r\n            } else {\r\n                if (ref.matches(this.typesSelector)){\r\n                    itemRefs.push(ref);\r\n                }\r\n                itemRefs.push(...ref.querySelectorAll(this.typesSelector));\r\n            }\r\n        }\r\n        return { options, itemRefs, trigger };\r\n    }\r\n\r\n    /**\r\n     * Create a new container\r\n     * @param {*} ref\r\n     * @param {object} [options]\r\n     * @param {?EventTarget} [trigger]\r\n     * @returns {?Container}\r\n     */\r\n    create(ref, options, trigger){\r\n        if (ref instanceof HTMLElement){\r\n            return new Container(this, ref, options, trigger);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new Container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {?Container}\r\n     */\r\n    parse(ref, handledRefs, nocache){\r\n        const { itemRefs, options, trigger } = this.getArgs(ref, nocache);\r\n        let container, cached = false;\r\n        if (this.#containerCache.has(ref)){\r\n            container = this.#containerCache.get(ref);\r\n            cached = true;\r\n        } else {\r\n            container = this.create(ref, options, trigger);\r\n        }\r\n        if (container instanceof Container){\r\n            const items = this.parseItems(container, itemRefs, handledRefs, nocache);\r\n            if (cached){\r\n                // compare items\r\n                const changes = this.compareItems(items, container.items);\r\n                container.items.length = 0;\r\n                container.items.push(...items);\r\n                if (changes.added.length > 0 || changes.removed.length > 0){\r\n                    this.trigger(\"updated-container\", [container, changes]);\r\n                }\r\n            } else {\r\n                container.items.push(...items);\r\n                this.trigger(\"added-container\", [container]);\r\n            }\r\n            this.#containerCache.set(ref, container);\r\n        }\r\n        return container;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied iterable collection of objects and returns an array of new ContainerItems.\r\n     * @param {Container} parent - The parent container for the items.\r\n     * @param {Iterable} refs - An iterable collection of reference objects to parse.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Item[]}\r\n     */\r\n    parseItems(parent, refs, handledRefs, nocache){\r\n        const results = [];\r\n        for (const ref of refs){\r\n            if (handledRefs.has(ref) || this.excludes(ref)) continue;\r\n            const item = this.parseItem(parent, ref, nocache);\r\n            if (!item) continue;\r\n            results.push(item);\r\n            handledRefs.add(ref);\r\n        }\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new ContainerItem.\r\n     * @param {Container} parent - The parent container for the item.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {?Item} Returns null if parsing fails or no type can parse the reference object.\r\n     */\r\n    parseItem(parent, ref, nocache){\r\n        const type = this.#types.find((type) => type.canParse(ref));\r\n        return type ? type.parse(parent, ref, nocache) : null;\r\n    }\r\n\r\n    /**\r\n     * Compares a containers current items against its cached items and reports any changes.\r\n     * @param {Item[]} current\r\n     * @param {Item[]} cached\r\n     * @returns {ParserChange}\r\n     */\r\n    compareItems(current, cached){\r\n        const removed = cached.filter((item) => !current.includes(item));\r\n        const added = current.filter((item) => !cached.includes(item));\r\n        return { removed, added };\r\n    }\r\n\r\n    //endregion\r\n}\r\n\r\nexport default Parser;","import containers from \"./ContainerController/config.pro\";\r\n\r\nexport default {\r\n    containers\r\n};","import parser_config from \"./Parser/config.pro\";\r\nimport groups_config from \"./GroupParser/config.pro\";\r\nimport GroupParser from \"./GroupParser\";\r\n\r\nexport default {\r\n    __parsers__: [\"default\", [\"groups\", GroupParser]],\r\n    default: parser_config,\r\n    groups: groups_config\r\n};","import {extend} from \"../../../../utils/object\";\r\nimport {isStringNotEmpty} from \"../../../../utils/is\";\r\nimport Parser from \"../Parser\";\r\nimport Container from \"../Container\";\r\nimport {asyncForEach} from \"../../../../utils/iasync\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {Parser~Configuration} GroupParser~Configuration\r\n * @property {number} [priority=99]\r\n */\r\n\r\n//endregion\r\n\r\nclass GroupParser extends Parser {\r\n\r\n    /**\r\n     * Get the parser configuration.\r\n     * @type {GroupParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        return super.config;\r\n    }\r\n\r\n    /**\r\n     * The default configuration.\r\n     * @returns {GroupParser~Configuration}\r\n     */\r\n    get defaults(){\r\n        return extend(super.defaults, {\r\n            priority: 99\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    async parseDocument(handledRefs, nocache) {\r\n        const results = [];\r\n        await asyncForEach(this.config.include, (selector) => {\r\n            if (!handledRefs.has(selector)){\r\n                const container = this.parse(selector, handledRefs, nocache);\r\n                if (container && container.items.length){\r\n                    results.push(container);\r\n                    handledRefs.add(selector);\r\n                }\r\n            }\r\n        });\r\n        this.purgeCache(results);\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    shouldPurge(container) {\r\n        return container.items.length === 0;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    create(ref, options, trigger){\r\n        if (isStringNotEmpty(ref)){\r\n            return new Container(this, ref, options, trigger);\r\n        }\r\n        return super.create(ref, options, trigger);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    getArgs(ref, nocache) {\r\n        if (isStringNotEmpty(ref)){\r\n            return { trigger: null, options: {}, itemRefs: document.querySelectorAll(ref) };\r\n        }\r\n        return super.getArgs(ref, nocache);\r\n    }\r\n\r\n}\r\n\r\nexport default GroupParser;","import * as is from \"./is\";\r\nimport * as obj from \"./object\"\r\n\r\nexport default {\r\n    is,\r\n    obj\r\n};","import Plugin from \"./Plugin\";\r\nimport defaults from \"./config.pro\";\r\nimport ContainerController from \"./ContainerController\";\r\n// import ModalController from \"./controllers/ModalController\";\r\n\r\nimport utils from \"../../utils\";\r\n\r\nconst plugin = new Plugin(defaults, ContainerController);\r\nplugin.utils = utils;\r\n\r\nglobal.FooBox = plugin;\r\n\r\nexport default plugin;","import {extend} from \"../../utils/object\";\r\nimport {isNumber, isString} from \"../../utils/is\";\r\nimport Emitter from \"../../utils/Emitter\";\r\n\r\nimport startTask from \"../../utils/task\";\r\n/**\r\n * @extends Emitter\r\n */\r\nclass Plugin extends Emitter {\r\n\r\n    /**\r\n     *\r\n     * @type {object}\r\n     */\r\n    config = {};\r\n\r\n    constructor(defaults, ContainerController) {\r\n        super();\r\n        this.config = defaults;\r\n        this.#containers = new ContainerController(this, \"containers\");\r\n        // this.#modals = new ModalController(this);\r\n    }\r\n\r\n    //region Controllers\r\n\r\n    /**\r\n     * The private field used by the 'containers' read-only property.\r\n     * @type {ContainerController}\r\n     * @private\r\n     */\r\n    #containers;\r\n\r\n    /**\r\n     * Get the containers for the plugin.\r\n     * @type {ContainerController}\r\n     * @readonly\r\n     */\r\n    get containers(){\r\n        return this.#containers;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'modals' read-only property.\r\n     * @type {ModalController}\r\n     * @private\r\n     */\r\n    #modals;\r\n\r\n    //endregion\r\n\r\n    //#region readyState\r\n\r\n    /**\r\n     * 0 - The plugin script has been evaluated but not yet initialized.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 0\r\n     */\r\n    get RS_DEFAULT(){ return 0; }\r\n\r\n    /**\r\n     * 1 - The configuration has been set but components have not been loaded yet.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 1\r\n     */\r\n    get RS_INITIALIZING(){ return 1; }\r\n\r\n    /**\r\n     * 2 - The components are loaded but long running tasks have not been run.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 2\r\n     */\r\n    get RS_INITIALIZED(){ return 2; }\r\n\r\n    /**\r\n     * 3 - Long running tasks have completed. The plugin is now ready.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 3\r\n     */\r\n    get RS_READY(){ return 3; }\r\n\r\n    /**\r\n     *\r\n     * @type {number}\r\n     */\r\n    #readyStateValue = this.RS_DEFAULT;\r\n\r\n    /**\r\n     * Get the current readyState\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 0\r\n     */\r\n    get readyState(){\r\n        return this.#readyStateValue;\r\n    }\r\n\r\n    /**\r\n     * Set the readyState value and trigger the \"readystatechange\" event.\r\n     * @private\r\n     * @param {number} value\r\n     * @fires Document#foobox-readystatechange\r\n     * @fires Plugin#readystatechange\r\n     * @throws {TypeError} Throws a TypeError if the value is not a number.\r\n     * @throws {RangeError} Throws a RangeError if the value is less than the current value or more than the RS_READY value.\r\n     */\r\n    set #readyState(value){\r\n        if (this.#readyStateValue === value) return; // do nothing\r\n        if (!isNumber(value)) throw new TypeError(\"The 'value' argument must be a number.\");\r\n        if (value < this.#readyStateValue) throw new RangeError(\"The 'value' argument can't be less than the current readyState.\");\r\n        if (value > this.RS_READY) throw new RangeError(\"The 'value' argument can't be more than the RS_READY value.\");\r\n        this.#readyStateValue = value;\r\n        /**\r\n         * Occurs whenever the readyState is changed.\r\n         * @event Document#foobox-readystatechange\r\n         * @param {CustomEvent} event - The readyState value can be accessed using the CustomEvent.detail property which is set to the plugin instance. e.g. event.detail.readyState\r\n         */\r\n        this.documentDispatch(\"foobox-readystatechange\");\r\n        /**\r\n         * Occurs whenever the readyState is changed.\r\n         * @event Plugin#readystatechange\r\n         * @param {EmitterEvent} event - The basic event object.\r\n         * @param {number} readyState - The readyState value.\r\n         */\r\n        this.trigger(\"readystatechange\", [value]);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Dispatch an event on the document.\r\n     * @param {string|Event} event - If given a string a CustomEvent is dispatched using the value as the type.\r\n     * @param {eventOptions} [options] - Any additional options for the event. By default the detail option of CustomEvent objects created by this method is set to the plugin instance.\r\n     * @returns {boolean}\r\n     */\r\n    documentDispatch(event, options){\r\n        /** @typedef {{bubbles:?boolean,cancelable:?boolean,composed:?boolean,detail:*}} eventOptions */\r\n        if (isString(event)){\r\n            event = new CustomEvent(event, extend({ detail: this }, options));\r\n        }\r\n        if (event instanceof Event){\r\n            return document.dispatchEvent(event);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param configuration\r\n     */\r\n    async init( configuration ) {\r\n        if ( this.readyState !== this.RS_DEFAULT ) return;\r\n        const task = startTask( 'foobox:init()' );\r\n        extend( this.config, configuration );\r\n        this.#readyState = this.RS_INITIALIZING;\r\n        this.#containers.init();\r\n        this.#readyState = this.RS_INITIALIZED;\r\n        await this.#containers.parseDocument( true );\r\n        this.#readyState = this.RS_READY;\r\n        task.end();\r\n    }\r\n\r\n    registerParser(name, configuration, ctor){\r\n        return this.#containers.registerParser(name, configuration, ctor);\r\n    }\r\n\r\n    async parseDocument(nocache){\r\n        return await this.#containers.parseDocument(nocache);\r\n    }\r\n\r\n    parse(ref, nocache){\r\n        return this.#containers.parse(ref, nocache);\r\n    }\r\n}\r\n\r\nexport default Plugin;","import {defaults, extend} from \"../../../utils/object\";\r\nimport {asyncForEach} from \"../../../utils/iasync\";\r\nimport {isFunction, isPlainObject} from \"../../../utils/is\";\r\nimport Parser from \"./Parser\";\r\nimport Emitter from \"../../../utils/Emitter\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {object} ContainerController~Configuration\r\n * @property {parserDefinition[]} [__parsers__]\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new instance of the ContainerController.\r\n * @extends Emitter\r\n * @param {Plugin} parent - A reference to the parent plugin controller.\r\n */\r\nclass ContainerController extends Emitter {\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of the ContainerController.\r\n     * @constructs\r\n     * @param {Plugin} plugin - A reference to the parent plugin controller.\r\n     * @param {string} name - The name the containers were registered with.\r\n     */\r\n    constructor(plugin, name) {\r\n        super({bubbles: true}, plugin);\r\n        this.#plugin = plugin;\r\n        this.#name = name;\r\n        defaults(this.config, this.defaults);\r\n        this.on({\r\n            \"added-container\": this.#onAddedContainer,\r\n            \"removed-container\": this.#onRemovedContainer,\r\n            \"updated-container\": this.#onUpdatedContainer\r\n        }, this);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n\r\n    /**\r\n     * Get the name of the component.\r\n     * @type {string}\r\n     * @readonly\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'plugin' read-only property.\r\n     * @type {Plugin}\r\n     * @private\r\n     */\r\n    #plugin;\r\n\r\n    /**\r\n     * Get the plugin instance.\r\n     * @type {Plugin}\r\n     * @readonly\r\n     */\r\n    get plugin(){\r\n        return this.#plugin;\r\n    }\r\n\r\n    /**\r\n     * Get the default containers configuration.\r\n     * @type {ContainerController~Configuration}\r\n     * @readonly\r\n     */\r\n    get defaults(){\r\n        return {\r\n            __parsers__: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the containers configuration.\r\n     * @type {ContainerController~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if (isPlainObject(this.plugin.config[this.name])){\r\n            return this.plugin.config[this.name];\r\n        }\r\n        return this.plugin.config[this.name] = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Container>}\r\n     */\r\n    #containers = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<EventTarget, EventListener>}\r\n     */\r\n    #triggers = new Map();\r\n\r\n    /**\r\n     * Used to ensure multiple calls to the parseDocument method during parsing all return the same result instead of simply kicking off multiple parses.\r\n     * @type {Promise<Container[]>}\r\n     * @private\r\n     */\r\n    #parseDocument = null;\r\n\r\n    /**\r\n     *\r\n     * @type {Parser[]}\r\n     */\r\n    #parsers = [];\r\n\r\n    /**\r\n     *\r\n     * @type {Parser[]}\r\n     * @readonly\r\n     */\r\n    get __parsers__(){\r\n        return this.#parsers;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Initializes the container controller.\r\n     */\r\n    init(){\r\n        if (this.plugin.readyState !== this.plugin.RS_INITIALIZING) return;\r\n        this.#parsers = Parser.createAll(this, this.config.__parsers__);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @param {object} [configuration]\r\n     * @param {Parser~ctor} [ctor]\r\n     * @returns {boolean}\r\n     */\r\n    registerParser(name, configuration, ctor){\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED && !this.config.hasOwnProperty(name)){\r\n            const Parser_ctor = isFunction(ctor) ? ctor : Parser;\r\n            this.config.__parsers__.push([name, Parser_ctor]);\r\n            this.config[name] = extend({}, configuration);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @returns {boolean}\r\n     */\r\n    unregisterParser(name){\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED && this.config.hasOwnProperty(name)){\r\n            this.config.__parsers__ = this.config.__parsers__.filter((config) => {\r\n                const parser = Parser.DEFINITION(config);\r\n                return parser ? parser.name !== name : false;\r\n            });\r\n            delete this.config[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Remove any trigger listeners registered using the addTrigger method.\r\n     * @param {?EventTarget} eventTarget\r\n     */\r\n    removeTriggerListener(eventTarget){\r\n        if (eventTarget instanceof EventTarget && this.#triggers.has(eventTarget)){\r\n            const listener = this.#triggers.get(eventTarget);\r\n            eventTarget.removeEventListener(\"click\", listener, false);\r\n            this.#triggers.delete(eventTarget);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up a trigger listener on the target.\r\n     * @param {?EventTarget} eventTarget\r\n     * @param {Container} container\r\n     * @param {?Item} [item]\r\n     */\r\n    addTriggerListener(eventTarget, container, item){\r\n        if (eventTarget instanceof EventTarget){\r\n            if (this.#triggers.has(eventTarget)){\r\n                // if there was a listener already cached then remove it before adding the new one\r\n                eventTarget.removeEventListener(\"click\", this.#triggers.get(eventTarget), false);\r\n            }\r\n            const listener = (e) => {\r\n                e.preventDefault();\r\n                this.trigger(\"triggered-container\", [container, item]);\r\n            };\r\n            // add the listener to the internal cache, this will update the listener if it existed\r\n            this.#triggers.set(eventTarget, listener);\r\n            eventTarget.addEventListener(\"click\", listener, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all document parsers.\r\n     * @returns {Parser[]}\r\n     */\r\n    getDocumentParsers(){\r\n        return this.#parsers.filter((parser) => parser.isDocumentParser);\r\n    }\r\n\r\n    /**\r\n     * Try get a parser for the reference.\r\n     * @param {*} ref\r\n     * @returns {?Parser}\r\n     */\r\n    getRefParser(ref){\r\n        return this.#parsers.find((parser) => parser.canParse(ref)) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Get all containers for this instance of the plugin.\r\n     * @returns {Container[]}\r\n     */\r\n    getAll(){\r\n        return Array.from(this.#containers.values());\r\n    }\r\n\r\n    /**\r\n     * Get a collection of references from all containers and items.\r\n     * @param {*} excludeRef - A reference to exclude from the result.\r\n     * @returns {Set<*>}\r\n     */\r\n    getRefs(excludeRef){\r\n        /** @type {Set<*>} */\r\n        const refs = new Set();\r\n        return this.getAll().reduce((result, container) => {\r\n            if (container.ref !== excludeRef){\r\n                result.add(container.ref);\r\n                container.items.forEach((item) => {\r\n                    if (item.ref === excludeRef) return;\r\n                    result.add(item.ref);\r\n                });\r\n            }\r\n            return result;\r\n        }, refs);\r\n    }\r\n\r\n    /**\r\n     * Parses the entire document and returns an array of Container objects.\r\n     * @async\r\n     * @param {boolean} [nocache=false] - Whether or not to disable the parser cache for this call.\r\n     * @returns {Promise<Container[]>} Returns an empty array if no Containers were parsed.\r\n     */\r\n    async parseDocument(nocache){\r\n        // if the plugin is not initialized yet return an empty array as we have no parsers to work with\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED) return [];\r\n        // if there is already parsing taking place simply return a reference to its promise\r\n        if (this.#parseDocument) return this.#parseDocument;\r\n        // otherwise we need to do some work\r\n        nocache = nocache ?? false;\r\n        return this.#parseDocument = new Promise(async (resolve) => {\r\n            const results = [], handledRefs = new Set();\r\n            await asyncForEach(this.getDocumentParsers(), async (parser) => {\r\n                const containers = await parser.parseDocument(handledRefs, nocache);\r\n                results.push(...containers);\r\n            });\r\n            this.#parseDocument = null;\r\n            resolve(results);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parse the supplied reference object into a Container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - Whether or not to disable the parser caching for this call.\r\n     * @returns {?Container} Returns null if the reference object could not be parsed.\r\n     */\r\n    parse(ref, nocache){\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED) return null;\r\n        nocache = nocache ?? false;\r\n        const parser = this.getRefParser(ref);\r\n        if (parser){\r\n            const handledRefs = this.getRefs(ref);\r\n            return parser.parse(ref, handledRefs, nocache);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region listeners\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     */\r\n    #onAddedContainer(event, container){\r\n        this.addTriggerListener(container.triggerTarget, container);\r\n        container.items.forEach((item) => this.addTriggerListener(item.triggerTarget, container, item));\r\n        this.#containers.set(container.ref, container);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     * @param {ParserChange} changes\r\n     */\r\n    #onUpdatedContainer(event, container, changes){\r\n        changes.removed.forEach((item) => this.removeTriggerListener(item.triggerTarget));\r\n        changes.added.forEach((item) => this.addTriggerListener(item.triggerTarget, container, item));\r\n        this.#containers.set(container.ref, container);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     */\r\n    #onRemovedContainer(event, container){\r\n        this.removeTriggerListener(container.triggerTarget);\r\n        container.items.forEach((item) => this.removeTriggerListener(item.triggerTarget));\r\n        this.#containers.delete(container.ref);\r\n    }\r\n\r\n    //endregion\r\n}\r\n\r\nexport default ContainerController;","/**\r\n * Check if the value is a boolean.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isBoolean(value){\r\n    return value != null && '[object Boolean]' === Object.prototype.toString.call(value);\r\n}\r\n\r\n/**\r\n * Check if the value is a function.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isFunction(value){\r\n    return value != null && (Object.prototype.toString.call(value) === \"[object Function]\" || typeof value === \"function\" || value instanceof Function);\r\n}\r\n\r\n/**\r\n * Check if the value is a number.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isNumber(value){\r\n    return value != null && '[object Number]' === Object.prototype.toString.call(value) && !isNaN(value);\r\n}\r\n\r\n/**\r\n * Check if the value is an object.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isObject(value){\r\n    return value != null && typeof value === \"object\";\r\n}\r\n\r\n/**\r\n * Check if the value is a plain object.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isPlainObject(value){\r\n    if (isObject(value)){\r\n        const proto = Object.getPrototypeOf(value);\r\n        return proto === Object.prototype || proto === null;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Check if the value is a promise.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isPromise(value){\r\n    return value != null && value instanceof Promise;\r\n}\r\n\r\n/**\r\n * Check if the value is a string.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isString(value){\r\n    return value != null && '[object String]' === Object.prototype.toString.call(value);\r\n}\r\n\r\nconst isEmptyString = /^\\s*$/;\r\n/**\r\n * Check if the value is a string and is not empty.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isStringNotEmpty(value){\r\n    return isString(value) && !isEmptyString.test(value);\r\n}\r\n\r\n/**\r\n * Check if the value is a undefined.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isUndefined(value){\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport {\r\n    isBoolean,\r\n    isFunction,\r\n    isNumber,\r\n    isObject,\r\n    isPlainObject,\r\n    isPromise,\r\n    isString,\r\n    isStringNotEmpty,\r\n    isUndefined\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t958: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkfoobox\"] = self[\"webpackChunkfoobox\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(408);\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","hasProperty","target","propertyName","isPlainObject","isStringNotEmpty","indexOf","hasOwnProperty","names","split","length","last","index","currentTarget","name","removeProperty","getProperty","defaultValue","setProperty","value","isUndefined","merge","source","objForEach","key","Array","isArray","slice","extend","sources","reduce","result","mergeMissing","missing","defaults","callback","Object","keys","forEach","call","this","objReduce","callbackFn","initialValue","previousValue","constructor","type","options","parsed","Emitter","namespace","isBoolean","bubbles","cancelable","defaultPrevented","emitterInstance","TypeError","currenTarget","preventDefault","isDefaultPrevented","stopPropagation","isPropagationStopped","static","required","parsedType","n_index","EVENT_TYPE_NAMESPACE_SEPARATOR","parentEmitter","Map","__events__","__emitterEventDefaults__","__parentEmitter__","listener","thisArg","isFunction","eventType","parseType","namespaces","get","set","listeners","thisArgs","Set","add","types","push","has","delete","size","args","on","typeOrTypeMap","typeListenerOrTypeMapThisArg","typeThisArg","arguments","off","emit","event","EmitterEvent","trigger","map","every","success","arrow","color","indent","style","backgroundColor","__types__","include","exclude","defaultProperties","obj","elem","test","image","priority","iframe","video","properties","filter","val","join","parent","ref","requiredProperties","triggerTarget","EventTarget","getProperties","nocache","PropertyParser","property","configuration","ctor","equalityComparer","sourceValue","some","targetValue","includes","mergeArray","targetDefinition","sourceDefinition","targetDef","DEFINITION","sourceDef","typeParser","definition","def","propertyParserDefinitions","propertyParser","create","getValue","convert","DEFAULT_CONVERT","DEFAULT_TEST","queryParent","queryPath","queryType","query","objectQuery","elementQuery","path","parts","pop","part","raw","targetRef","parents","selector","i","parentElement","querySelector","dataset","hasAttribute","getAttribute","HTMLElement","TypeParser","parser","typeParserDefinitions","config","sort","a","b","makeSelector","includeSelector","excludeSelector","matches","excludes","canParse","Item","parse","item","getTrigger","getRequiredProperties","Container","items","firstIndex","lastIndex","withinRange","isNumber","getByIndex","getFirst","getLast","getNext","current","allowLoop","nextIndex","getPrevious","previousIndex","toStringTag","Symbol","async","doCallback","Promise","resolve","setTimeout","asyncForEach","iterable","Parser","containers","parserDefinitions","super","data","typesSelector","isDocumentParser","dataName","JSON","err","console","error","handledRefs","results","document","querySelectorAll","container","purgeCache","values","shouldPurge","getArgs","itemRefs","cached","parseItems","changes","compareItems","added","removed","refs","parseItem","find","__parsers__","default","parser_config","groups","groups_config","is","plugin","ContainerController","RS_DEFAULT","RS_INITIALIZING","RS_INITIALIZED","RS_READY","readyState","RangeError","documentDispatch","isString","CustomEvent","detail","Event","dispatchEvent","task","startTime","performance","now","startFormat","debug","end","duration","diff","start","endFormat","toFixed","startTask","init","parseDocument","registerParser","Parser_ctor","unregisterParser","removeTriggerListener","eventTarget","removeEventListener","addTriggerListener","e","addEventListener","getDocumentParsers","getRefParser","getAll","from","getRefs","excludeRef","utils","global","FooBox","prototype","toString","Function","isNaN","isObject","proto","getPrototypeOf","isPromise","isEmptyString","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","O","chunkIds","fn","notFulfilled","Infinity","fulfilled","j","splice","r","d","o","defineProperty","enumerable","g","globalThis","window","prop","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","id","chunkLoadingGlobal","self","bind","__webpack_exports__"],"sourceRoot":""}