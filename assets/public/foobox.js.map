{"version":3,"file":"foobox.js","mappings":"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","sources":["webpack://foobox/webpack/runtime/chunk loaded","webpack://foobox/./src/utils/object.js","webpack://foobox/./src/utils/EmitterEvent.js","webpack://foobox/./src/utils/Emitter.js","webpack://foobox/./src/utils/task.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/config.js","webpack://foobox/./src/public/foobox/ContainerController/GroupParser/config.js","webpack://foobox/./src/utils/makeSelector.js","webpack://foobox/./src/public/foobox/ContainerController/Container/Item.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/TypeParser/PropertyParser/index.js","webpack://foobox/./src/utils/mergeArray.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/TypeParser/index.js","webpack://foobox/./src/public/foobox/ContainerController/Container/index.js","webpack://foobox/./src/utils/iasync.js","webpack://foobox/./src/public/foobox/ContainerController/Parser/index.js","webpack://foobox/./src/public/foobox/config.js","webpack://foobox/./src/public/foobox/ContainerController/config.js","webpack://foobox/./src/public/foobox/ContainerController/GroupParser/index.js","webpack://foobox/./src/utils/index.js","webpack://foobox/./src/public/foobox/index.js","webpack://foobox/./src/public/foobox/Plugin.js","webpack://foobox/./src/public/foobox/ContainerController/index.js","webpack://foobox/./src/utils/is.js","webpack://foobox/webpack/bootstrap","webpack://foobox/webpack/runtime/define property getters","webpack://foobox/webpack/runtime/global","webpack://foobox/webpack/runtime/hasOwnProperty shorthand","webpack://foobox/webpack/runtime/make namespace object","webpack://foobox/webpack/runtime/jsonp chunk loading","webpack://foobox/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import {isPlainObject, isStringNotEmpty, isUndefined} from \"./is\";\r\n\r\nfunction hasProperty(target, propertyName){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    return currentTarget.hasOwnProperty(name);\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return target.hasOwnProperty(propertyName);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Remove a property from an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n */\r\nfunction removeProperty(target, propertyName){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    delete currentTarget[name];\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                }\r\n            }\r\n        } else {\r\n            delete target[propertyName];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get the value of a property from an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n * @param {*} [defaultValue]\r\n * @returns {*}\r\n */\r\nfunction getProperty(target, propertyName, defaultValue){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    if (currentTarget.hasOwnProperty(name)){\r\n                        return currentTarget[name];\r\n                    }\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n        } else if (target.hasOwnProperty(propertyName)){\r\n            return target[propertyName];\r\n        }\r\n    }\r\n    return defaultValue;\r\n}\r\n\r\n/**\r\n * Set the value of a property in an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction setProperty(target, propertyName, value){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName) && !isUndefined(value)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    currentTarget[name] = value;\r\n                    return true;\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else if (isUndefined(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name] = {};\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            target[propertyName] = value;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Merge the properties of the source object into the target object replacing existing values.\r\n * @param {object} target - The object that will receive the properties.\r\n * @param {object} source - The object to extract properties from.\r\n * @returns {object}\r\n */\r\nfunction merge(target, source) {\r\n    target = isPlainObject(target) ? target : {};\r\n    if (isPlainObject(target) && isPlainObject(source)){\r\n        objForEach(source, (key, value) => {\r\n            if (isPlainObject(value)){\r\n                // if the source value is an object, merge it into the target key\r\n                target[key] = merge(target[key], value);\r\n            } else if (Array.isArray(value)){\r\n                // if the source value is an array, replace the target key with a shallow copy of it\r\n                target[key] = value.slice();\r\n            } else {\r\n                // otherwise replace the target key with the source value\r\n                target[key] = value;\r\n            }\r\n        });\r\n    }\r\n    // always return the original target object\r\n    return target;\r\n}\r\n\r\n/**\r\n * Merge the properties of all source objects into the target object replacing existing values.\r\n * @param {object} target\r\n * @param {...object} sources\r\n * @returns {object}\r\n */\r\nfunction extend(target, ...sources) {\r\n    target = isPlainObject(target) ? target : {};\r\n    return sources.reduce((result, source) => merge(result, source), target);\r\n}\r\n\r\n/**\r\n * Merge the properties of the source object into the target object if they do not exist.\r\n * @param {object} target - The object that will receive the properties.\r\n * @param {object} source - The object to extract properties from.\r\n * @returns {object}\r\n */\r\nfunction mergeMissing(target, source){\r\n    target = isPlainObject(target) ? target : {};\r\n    if (isPlainObject(source)){\r\n        objForEach(source, (key, value) => {\r\n            const missing = !target.hasOwnProperty(key);\r\n            if (isPlainObject(value)){ // if the source value is an object\r\n                if (isPlainObject(target[key])){ // and the target key is an object, merge the missing source properties\r\n                    target[key] = mergeMissing(target[key], value);\r\n                } else if (missing) { // otherwise if its missing, set the target key to the source value\r\n                    target[key] = merge({}, value);\r\n                }\r\n            } else if (missing) {\r\n                // if its just missing and not a special case, set the target key with the missing source value\r\n                target[key] = value;\r\n            }\r\n        });\r\n    }\r\n    // always return the original target object\r\n    return target;\r\n}\r\n\r\n/**\r\n * Merge the properties of all source objects into the target object if they do not exist.\r\n * @param {object} target\r\n * @param {...object} sources\r\n * @returns {object}\r\n */\r\nfunction defaults(target, ...sources){\r\n    target = isPlainObject(target) ? target : {};\r\n    return sources.reduce((result, source) => mergeMissing(result, source), target);\r\n}\r\n\r\n/**\r\n * @callback objForEach~callback\r\n * @param {string} key\r\n * @param {*} value\r\n */\r\n\r\n/**\r\n * Iterates all keys of the target and executes the callback for each supplying the current key and value.\r\n * @param {object} target - The target object to iterate.\r\n * @param {objForEach~callback} callback - The callback to execute.\r\n */\r\nfunction objForEach(target, callback){\r\n    Object.keys(target).forEach((key) => {\r\n        callback.call(this, key, target[key]);\r\n    });\r\n}\r\n\r\n/**\r\n * A \"reducer\" function that can take up to four arguments.\r\n * @callback objReduce~callback\r\n * @template T\r\n * @param {T} previousValue - The value resulting from the previous call to the callback.\r\n * @param {*} value - The value of the current key.\r\n * @param {string} [key] - The current key of the object.\r\n * @param {object} [object] - The object being iterated.\r\n * @returns {T}\r\n */\r\n/**\r\n * The objReduce() method executes a user-supplied “reducer” callback function on each key~value pair of the target object,\r\n * passing in the return value from the calculation on the preceding pair. The final result of running the reducer across\r\n * all key~value pairs of the target object is a single value.\r\n * @template T\r\n * @param {object} target - The object to reduce.\r\n * @param {objReduce~callback<T>} callbackFn - A \"reducer\" function that takes four arguments.\r\n * @param {T} [initialValue] - A value to which \"previousValue\" is initialized the first time the callback is called.\r\n * @returns {T} The value that results from running the “reducer” callback function to completion over the entire object.\r\n */\r\nfunction objReduce(target, callbackFn, initialValue){\r\n    return Object.keys(target).reduce((previousValue, key) => {\r\n        return callbackFn.call(this, previousValue, target[key], key);\r\n    }, initialValue);\r\n}\r\n\r\nexport {\r\n    objForEach,\r\n    objReduce,\r\n    hasProperty,\r\n    removeProperty,\r\n    getProperty,\r\n    setProperty,\r\n    merge,\r\n    extend,\r\n    mergeMissing,\r\n    defaults\r\n};","import {isBoolean, isPlainObject, isStringNotEmpty} from \"./is\";\r\nimport Emitter from \"./Emitter\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {object} EmitterEventOptions\r\n * @property {boolean} [bubbles=false] - Whether or not the event is bubbled.\r\n * @property {boolean} [cancelable=false] - Whether or not the event can be canceled using preventDefault.\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new EmitterEvent instance.\r\n * @class EmitterEvent\r\n * @param {string} type - The type of the event.\r\n * @param {EmitterEventOptions} [options] - The options for the event.\r\n * @param {Emitter} [target] - The target for the event.\r\n * @throws {TypeError} Throws a TypeError if the supplied `type` is invalid.\r\n */\r\nclass EmitterEvent {\r\n\r\n    //#region constructor\r\n\r\n    /**\r\n     * @constructs\r\n     * @param {string} type - The type of the event.\r\n     * @param {EmitterEventOptions} [options] - The options for the event.\r\n     * @param {Emitter} [target] - The target for the event.\r\n     * @throws {TypeError} Throws a TypeError if the supplied `type` is invalid.\r\n     */\r\n    constructor(type, options, target) {\r\n        const parsed = Emitter.parseType(type, true);\r\n        this.#type = parsed.type;\r\n        this.#namespace = parsed.namespace;\r\n        if (isPlainObject(options)){\r\n            this.#bubbles = isBoolean(options.bubbles) ? options.bubbles : false;\r\n            this.#cancelable = isBoolean(options.cancelable) ? options.bubbles : false;\r\n        }\r\n        if (target instanceof Emitter){\r\n            this.#target = this.#currenTarget = target;\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region properties\r\n\r\n    /**\r\n     * The private field used by the type read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #type;\r\n    /**\r\n     * The type of event.\r\n     * @type {string}\r\n     * @readonly\r\n     */\r\n    get type(){\r\n        return this.#type;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the namespace read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #namespace = null;\r\n    /**\r\n     * The namespace of the event.\r\n     * @type {?string}\r\n     * @readonly\r\n     * @default null\r\n     */\r\n    get namespace(){\r\n        return this.#namespace;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the bubbles read-only property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #bubbles = false;\r\n    /**\r\n     * Whether or not the event is bubbled.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get bubbles(){\r\n        return this.#bubbles;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the cancelable read-only property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #cancelable = false;\r\n    /**\r\n     * Whether or not the event is cancelable.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get cancelable(){\r\n        return this.#cancelable;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the defaultPrevented readonly property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #defaultPrevented = false;\r\n    /**\r\n     * Whether or not the event is cancelable and preventDefault has been called.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get defaultPrevented(){\r\n        return this.#defaultPrevented;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the target readonly property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #target = null;\r\n    /**\r\n     * The emitter that initially raised the event.\r\n     * @type {?Emitter}\r\n     * @default null\r\n     */\r\n    get target(){\r\n        return this.#target;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter that raised the event.\r\n     * @param {Emitter} emitterInstance\r\n     * @throws {TypeError} Throws a TypeError if the value is not an instance of Emitter.\r\n     */\r\n    set target(emitterInstance){\r\n        if (emitterInstance instanceof Emitter){\r\n            this.#target = emitterInstance;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The EmitterEvent.target must be an instance of Emitter.\");\r\n    }\r\n\r\n    /**\r\n     * The private field used by the currenTarget readonly property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #currenTarget = null;\r\n    /**\r\n     * The emitter currently raising the event.\r\n     * @type {?Emitter}\r\n     * @default null\r\n     */\r\n    get currenTarget(){\r\n        return this.#currenTarget;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter currently raising the event.\r\n     * @param {Emitter} emitterInstance\r\n     * @throws {TypeError} Throws a TypeError if the value is not an instance of Emitter.\r\n     */\r\n    set currenTarget(emitterInstance){\r\n        if (emitterInstance instanceof Emitter){\r\n            this.#currenTarget = emitterInstance;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The EmitterEvent.currenTarget must be an instance of Emitter.\");\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Specifies the default action should not be taken. Calling this method on a non-cancelable event has no effect.\r\n     */\r\n    preventDefault() {\r\n        if (!this.cancelable) return;\r\n        this.#defaultPrevented = true;\r\n    }\r\n\r\n    /**\r\n     * Whether or not the default action should not be taken.\r\n     * @returns {boolean}\r\n     */\r\n    isDefaultPrevented() {\r\n        return this.defaultPrevented;\r\n    }\r\n\r\n    #propagationStopped = false;\r\n    stopPropagation(){\r\n        this.#propagationStopped = true;\r\n    }\r\n\r\n    isPropagationStopped(){\r\n        return this.#propagationStopped;\r\n    }\r\n\r\n    //endregion\r\n\r\n}\r\n\r\nexport default EmitterEvent;","import {isFunction, isPlainObject, isStringNotEmpty, isUndefined} from \"./is\";\r\nimport EmitterEvent from \"./EmitterEvent\";\r\nimport {defaults, objForEach} from \"./object\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * A function that can handle an event emitted by an Emitter object.\r\n * @callback EmitterListener\r\n * @param {EmitterEvent} [event]\r\n * @param {...*} [args]\r\n */\r\n/**\r\n * An object containing event type to listener mappings.\r\n * @typedef {object} EmitterMap\r\n * @example\r\n *  {\r\n *      \"some-event\": (event, ...args) => { },\r\n *      \"another-event\": (event, ...args) => { }\r\n *  }\r\n */\r\n/**\r\n * The result of the Emitter.parseType method.\r\n * @typedef {object} EmitterType\r\n * @property {?string} [type] - The type of the event.\r\n * @property {?string} [namespace] - The namespace for the event.\r\n */\r\n/**\r\n * A map of event type to namespaces.\r\n * @typedef {Map<string, EmitterNamespaces>} EmitterEvents\r\n */\r\n/**\r\n * A map of namespace to listeners.\r\n * @typedef {Map<?string, EmitterListeners>} EmitterNamespaces\r\n */\r\n/**\r\n * A map of listener to thisArgs\r\n * @typedef {Map<EmitterListener, Set<*>>} EmitterListeners\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new Emitter instance.\r\n * @class Emitter\r\n * @param {EmitterEventOptions} [options] - The default options for events created by this instance.\r\n * @param {Emitter} [parentEmitter] - The parent emitter for this instance.\r\n */\r\nclass Emitter {\r\n\r\n    //region static\r\n\r\n    /**\r\n     * The separator used to parse eventType strings into there component type and namespace values.\r\n     * @type {string}\r\n     * @default \".\"\r\n     */\r\n    static EVENT_TYPE_NAMESPACE_SEPARATOR = \".\";\r\n\r\n    /**\r\n     * Parses the supplied event type string into its component type and namespace values.\r\n     * @param {string} type - The event type string to parse.\r\n     * @param {boolean} [required=false] - Whether or not to throw a TypeError if the parsed type is empty.\r\n     * @returns {EmitterType}\r\n     * @throws {TypeError} Throws a TypeError if the supplied `type` or return value is invalid.\r\n     */\r\n    static parseType(type, required){\r\n        if (!isStringNotEmpty(type)) {\r\n            throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        }\r\n        let namespace = null, parsedType = type;\r\n        const n_index = type.indexOf(this.EVENT_TYPE_NAMESPACE_SEPARATOR);\r\n        if (n_index !== -1){\r\n            namespace = type.slice(n_index + 1) || null;\r\n            parsedType = type.slice(0, n_index) || null;\r\n        }\r\n        if ((!namespace && !parsedType) || (!parsedType && required)){\r\n            throw new TypeError(`Unable to parse the event type: \"${type}\"`);\r\n        }\r\n        return { type: parsedType, namespace };\r\n    }\r\n\r\n    //endregion\r\n\r\n    //#region constructor\r\n\r\n    /**\r\n     * @constructs\r\n     * @param {EmitterEventOptions} [options] - The default options for events created by this instance.\r\n     * @param {Emitter} [parentEmitter] - The parent emitter for this instance.\r\n     */\r\n    constructor(options, parentEmitter) {\r\n        this.#emitterEventDefaults = {...this.#emitterEventDefaults, ...options};\r\n        this.#parentEmitter = parentEmitter instanceof Emitter ? parentEmitter : null;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the __events__ read-only property.\r\n     * @type {EmitterEvents}\r\n     * @private\r\n     */\r\n    #events = new Map();\r\n\r\n    /**\r\n     * A map of event types to handler arrays for this instance.\r\n     * @type {EmitterEvents}\r\n     * @readonly\r\n     */\r\n    get __events__(){\r\n        return this.#events;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the __emitterEventDefaults__ read-only property.\r\n     * @type {EmitterEventOptions}\r\n     * @private\r\n     */\r\n    #emitterEventDefaults = {\r\n        bubbles: false,\r\n        cancelable: false\r\n    };\r\n\r\n    /**\r\n     * The default options for events created by this instance. Should be set through the constructor call.\r\n     * @type {EmitterEventOptions}\r\n     * @readonly\r\n     */\r\n    get __emitterEventDefaults__(){\r\n        return this.#emitterEventDefaults;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the __parentEmitter__ read-only property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #parentEmitter = null;\r\n\r\n    /**\r\n     * The parent emitter for this instance.\r\n     * @type {?Emitter}\r\n     * @readonly\r\n     */\r\n    get __parentEmitter__(){\r\n        return this.#parentEmitter;\r\n    }\r\n\r\n    //endregion\r\n\r\n    /**\r\n     * Sets up a function that will be called whenever the specified event is delivered to the target.\r\n     * @param {string} type - A case-sensitive string representing the event type to listen for.\r\n     * @param {EmitterListener} listener - The callback that receives a notification when an event of the specified type occurs.\r\n     * @param {*} [thisArg] - The value of this within the listener.\r\n     */\r\n    #addListener(type, listener, thisArg) {\r\n        if (!isStringNotEmpty(type)) throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        if (!isFunction(listener)) throw new TypeError(\"The 'listener' argument must be a function.\");\r\n        thisArg = thisArg ?? this;\r\n        type.split(\" \").forEach((eventType) => {\r\n            if (!isStringNotEmpty(eventType)) return;\r\n            const parsed = Emitter.parseType(eventType, true);\r\n            let namespaces = this.#events.get(parsed.type);\r\n            if (!namespaces) this.#events.set(parsed.type, (namespaces = new Map()));\r\n            let listeners = namespaces.get(parsed.namespace);\r\n            if (!listeners) namespaces.set(parsed.namespace, (listeners = new Map()));\r\n            let thisArgs = listeners.get(listener);\r\n            if (!thisArgs) listeners.set(listener, (thisArgs = new Set()));\r\n            thisArgs.add(thisArg);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes an event listener previously registered with Emitter.addEmitterListener\r\n     * @param {string} type - A string which specifies the type of event for which to remove an event listener.\r\n     * @param {EmitterListener} [listener] - The listener of the event handler to remove. If not supplied all listeners for the event type are removed.\r\n     * @param {*} [thisArg] - The thisArg value of the event handler to remove. If not supplied all listeners that match the listener and event type are removed.\r\n     */\r\n    #removeListener(type, listener, thisArg) {\r\n        if (!isStringNotEmpty(type)) throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        thisArg = thisArg ?? this;\r\n        type.split(\" \").forEach((eventType) => {\r\n            if (!isStringNotEmpty(eventType)) return;\r\n            const parsed = Emitter.parseType(eventType);\r\n            const types = [];\r\n            if (isStringNotEmpty(parsed.type)) {\r\n                types.push(parsed.type);\r\n            } else if (isStringNotEmpty(parsed.namespace)) {\r\n                for (const [type, namespaces] of this.#events){\r\n                    if (!namespaces.has(parsed.namespace)) continue;\r\n                    types.push(type);\r\n                }\r\n            }\r\n            types.forEach((type) => {\r\n                // a type was provided but doesn't exist so do nothing\r\n                if (!this.#events.has(type)) return;\r\n                const namespaces = this.#events.get(type);\r\n                // a namespace was provided but doesn't exist so do nothing\r\n                if (!namespaces.has(parsed.namespace)) return;\r\n                if (isFunction(listener)){\r\n                    const listeners = namespaces.get(parsed.namespace);\r\n                    // a listener was provided but doesn't exist so do nothing\r\n                    if (!listeners.has(listener)) return;\r\n                    if (!isUndefined(thisArg)){\r\n                        const thisArgs = listeners.get(listener);\r\n                        // a thisArg was provided but doesn't exist so do nothing\r\n                        if (!thisArgs.has(thisArg)) return;\r\n                        // remove just the specified thisArg for the type, namespace & listener\r\n                        thisArgs.delete(thisArg);\r\n                        // if the last thisArg was removed then remove the listener\r\n                        if (thisArgs.size === 0) listeners.delete(listener);\r\n                    } else {\r\n                        // no thisArg was provided so just remove the entire listener for the type & namespace\r\n                        listeners.delete(listener);\r\n                    }\r\n                    // if the last listener was removed then remove the namespace\r\n                    if (listeners.size === 0) namespaces.delete(parsed.namespace);\r\n                } else {\r\n                    // no listener was provided so remove all listeners for the type & namespace\r\n                    namespaces.delete(parsed.namespace);\r\n                }\r\n                // if the last namespace was removed then remove the type\r\n                if (namespaces.size === 0) this.#events.delete(type);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The callback executed for each event type and listener parsed from the arguments.\r\n     * @callback forListener~callback\r\n     * @param {string} type\r\n     * @param {EmitterListener} listener\r\n     * @param {*} thisArg\r\n     * @this {Emitter}\r\n     */\r\n    /**\r\n     * Parse and iterate over the arguments supplied to the .on() and .off() methods.\r\n     * @param {IArguments} args\r\n     * @param {forListener~callback} callback\r\n     * @param {*} [thisArg] - The initial value of the thisArg.\r\n     * @private\r\n     */\r\n    #forListener(args, callback, thisArg){\r\n        if (args.length >= 2 && isStringNotEmpty(args[0]) && isFunction(args[1])) {\r\n            // dealing with (type, listener) OR (type, listener, thisArg)\r\n            if (args.length === 3) thisArg = args[2];\r\n            callback.call(this, args[0], args[1], thisArg);\r\n        } else if (args.length >= 1 && isPlainObject(args[0])) {\r\n            // dealing with (EmitterMap) OR (EmitterMap, thisArg)\r\n            if (args.length === 2) thisArg = args[1];\r\n            objForEach(args[0], (type, listener) => {\r\n                callback.call(this, type, listener, thisArg);\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add event listeners to this instance.\r\n     * @param {string|EmitterMap} typeOrTypeMap - A event type string or an object map of event type keys to listener values.\r\n     * @param {EmitterListener|*} [typeListenerOrTypeMapThisArg] - If the first parameter is a string, this should be a listener function. If the first parameter is an object, this is the thisArg to bind all listeners with.\r\n     * @param {*} [typeThisArg] - If the first parameter is a string and the second a listener, this is the thisArg to bind the listener with.\r\n     * @returns {this}\r\n     */\r\n    on(typeOrTypeMap, typeListenerOrTypeMapThisArg, typeThisArg){\r\n        return this.#forListener(arguments, this.#addListener);\r\n    }\r\n\r\n    /**\r\n     * Remove event listeners from this instance.\r\n     * @param {string|EmitterMap} typeOrTypeMap - A event type string or an object map of event type keys to listener values.\r\n     * @param {EmitterListener|*} [typeListenerOrTypeMapThisArg] - If the first parameter is a string, this should be a listener function. If the first parameter is an object, this is the thisArg to bind all listeners with.\r\n     * @param {*} [typeThisArg] - If the first parameter is a string and the second a listener, this is the thisArg to bind the listener with.\r\n     * @returns {this}\r\n     */\r\n    off(typeOrTypeMap, typeListenerOrTypeMapThisArg, typeThisArg){\r\n        return this.#forListener(arguments, this.#removeListener);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {...*} [args]\r\n     * @returns {boolean} Returns true if defaultPrevented was not called.\r\n     */\r\n    emit(event, ...args) {\r\n        if (event instanceof EmitterEvent) {\r\n            if (event.target === null) event.target = this;\r\n            if (event.currenTarget !== this) event.currenTarget = this;\r\n            const emit = (namespaces) => {\r\n                if (!namespaces.has(event.namespace)) return;\r\n                const listeners = namespaces.get(event.namespace);\r\n                for (const [listener, thisArgs] of listeners) {\r\n                    for (const thisArg of thisArgs) {\r\n                        listener.call(thisArg, event, ...args);\r\n                    }\r\n                }\r\n            };\r\n            if (this.#events.has(event.type)) {\r\n                emit(this.#events.get(event.type));\r\n            }\r\n            if (this.#events.has(\"*\")) {\r\n                emit(this.#events.get(\"*\"));\r\n            }\r\n            if (event.bubbles && !event.isPropagationStopped() && this.#parentEmitter instanceof Emitter) {\r\n                return this.#parentEmitter.emit(event, ...args);\r\n            }\r\n            return !event.isDefaultPrevented();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} event\r\n     * @param {Array} [args]\r\n     * @param {EmitterEventOptions} [options]\r\n     * @returns {boolean}\r\n     */\r\n    trigger(event, args, options) {\r\n        if (!isStringNotEmpty(event)) return false;\r\n        args = Array.isArray(args) ? args : [];\r\n        options = defaults(options, this.#emitterEventDefaults);\r\n        return event.split(\" \")\r\n            .map((type) => this.emit(new EmitterEvent(type, options, this), ...args))\r\n            .every((success) => success);\r\n    }\r\n}\r\n\r\nexport default Emitter;","const arrow = (color, indent = 0) => `color: ${color}; text-indent:${(0.4 * 4) * indent}em; padding: 0.4em; margin-right: 0.4em;`;\r\nconst style = (color, backgroundColor) => `display: inline-block; color: ${color}; background-color: ${backgroundColor}; border-radius: 3px; padding: 0.4em; margin-right: 0.4em;`;\r\nconst diff = (start, end) => {\r\n    const value = end - start,\r\n        color = value > 50 ? \"red\" : (value > 25 ? \"darkorange\" : \"green\");\r\n    return { value, color };\r\n};\r\n\r\nexport default function start(name){\r\n    const startTime = performance.now();\r\n    const startFormat = `%c-->%c${name}`;\r\n    console.debug(startFormat, arrow('green'), style(\"gray\", \"white\"));\r\n    return {\r\n        end: () => {\r\n            const duration = diff(startTime, performance.now());\r\n            const endFormat = `%c<--%c${name}%c${duration.value.toFixed(2)}ms`;\r\n            console.debug(endFormat, arrow('red'), style(\"gray\", \"white\"), style(\"white\", duration.color));\r\n        }\r\n    };\r\n};","import {isStringNotEmpty} from \"../../../../utils/is\";\r\n\r\nexport default {\r\n    __types__: [\"image\",\"iframe\"],\r\n    include: [\".foobox,[data-foobox],[data-foobox-items]\"],\r\n    exclude: [\".nolightbox\"],\r\n    defaultProperties: [{\r\n        name: \"url\",\r\n        obj: [\"url\",\"href\"],\r\n        elem: [\"data:href\",\"data:url\",\"href\"],\r\n        required: true,\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"title\",\r\n        obj: [\"title\"],\r\n        elem: [\"data:title\", \"title\", \"img/title\"],\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"description\",\r\n        obj: [\"description\"],\r\n        elem: [\"data:description\", \"img/alt\"],\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"width\",\r\n        obj: [\"width\"],\r\n        elem: [\"data:width\"]\r\n    },{\r\n        name: \"height\",\r\n        obj: [\"height\"],\r\n        elem: [\"data:height\"]\r\n    },{\r\n        name: \"aspectRatio\",\r\n        obj: [\"aspectRatio\"],\r\n        elem: [\"data:aspectRatio\"]\r\n    }],\r\n    image: {\r\n        priority: 10,\r\n        include: [\r\n            \"[href^='http'][href*='.svg']\",\r\n            \"[href^='http'][href*='.png']\",\r\n            \"[href^='http'][href*='.jpg']\",\r\n            \"[href^='http'][href*='.jpeg']\",\r\n            \"[href^='http'][href*='.webp']\",\r\n            \"[href^='http'][href*='.gif']\",\r\n            \"[href^='http'][href*='.bmp']\",\r\n            \"[href^='http'][href*='fakeimg.pl']\",\r\n            \"[href^='http'].foobox-image\"\r\n        ],\r\n        exclude: []\r\n    },\r\n    iframe: {\r\n        priority: 20,\r\n        include: [\r\n            \"[href^='http'][target='foobox']\",\r\n            \"[href^='http'].foobox-iframe\"\r\n        ],\r\n        exclude: []\r\n    }\r\n};","import defaults from \"../Parser/config\";\r\n\r\nexport default {\r\n    ...defaults,\r\n    include: []\r\n};","import {isStringNotEmpty} from \"./is\";\r\n\r\n/**\r\n * If the value is a string it is returned, if it's a string array the values are joined using a comma, otherwise null is returned.\r\n * @param {*} value\r\n * @returns {?string}\r\n */\r\nfunction makeSelector(value){\r\n    if (isStringNotEmpty(value)) {\r\n        return value;\r\n    }\r\n    if (Array.isArray(value) && value.length) {\r\n        const result = value.filter((val) => isStringNotEmpty(val)).join(\",\");\r\n        return isStringNotEmpty(result) ? result : null;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport default makeSelector;","/**\r\n * A simple class containing the results of a parsed item.\r\n */\r\nclass Item {\r\n    /**\r\n     * A reference to the parent container this item belongs to.\r\n     */\r\n    parent;\r\n\r\n    /**\r\n     * A reference to the type parser that produced this item.\r\n     * @type {TypeParser}\r\n     */\r\n    type;\r\n\r\n    /**\r\n     * The reference object parsed.\r\n     * @type {*}\r\n     */\r\n    ref;\r\n\r\n    /**\r\n     * An object containing all required properties for the item.\r\n     * @type {object}\r\n     */\r\n    requiredProperties;\r\n\r\n    /**\r\n     * @type {?EventTarget}\r\n     * @private\r\n     */\r\n    #triggerTarget = null;\r\n\r\n    /**\r\n     * Create a new instance of the ParserItem class.\r\n     * @param {Container} parent - A reference to the parent container this item belongs to.\r\n     * @param {TypeParser} type - A reference to the type parser that produced this item.\r\n     * @param {*} ref - The reference object parsed.\r\n     * @param {?EventTarget} [triggerTarget] - The EventTarget instance that triggers this item.\r\n     */\r\n    constructor(parent, type, ref, triggerTarget) {\r\n        this.parent = parent;\r\n        this.type = type;\r\n        this.ref = ref;\r\n        if (triggerTarget instanceof EventTarget){\r\n            this.#triggerTarget = triggerTarget;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The EventTarget instance that triggers this item.\r\n     * @returns {?EventTarget}\r\n     */\r\n    get triggerTarget(){\r\n        return this.#triggerTarget;\r\n    }\r\n\r\n    /**\r\n     * @param {EventTarget} value - The EventTarget instance to use as the trigger.\r\n     */\r\n    set triggerTarget(value){\r\n        if (value instanceof EventTarget){\r\n            this.#triggerTarget = value;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The Item.trigger property must be an instance of EventTarget!\");\r\n    }\r\n\r\n    /**\r\n     * Get all properties for this item.\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {object}\r\n     */\r\n    getProperties(nocache){\r\n        const properties = this.type.getProperties(this.ref, nocache);\r\n        return { ...properties, type: this.type.name };\r\n    }\r\n}\r\n\r\nexport default Item;","import {isFunction, isPlainObject, isStringNotEmpty} from \"../../../../../../utils/is\";\r\nimport mergeArray from \"../../../../../../utils/mergeArray\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback PropertyParser~ctor\r\n * @param {TypeParser} parent\r\n * @param {PropertyParser~Configuration} configuration\r\n * @returns {PropertyParser}\r\n */\r\n/**\r\n * @typedef {object} PropertyParserDefinition\r\n * @property {PropertyParser~Configuration} configuration\r\n * @property {PropertyParser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default property parser is registered using the new name. If an array, the first element is the name, the second is the custom property parser constructor.\r\n * @typedef {PropertyParser~Configuration|[PropertyParser~Configuration,PropertyParser~ctor]} propertyParserDefinition\r\n */\r\n/**\r\n * A method used to test the parsed value to check if it is valid.\r\n * @callback PropertyParser~test\r\n * @param {*} value\r\n * @param {PropertyParser} [propertyParser]\r\n * @returns {boolean}\r\n */\r\n/**\r\n * A method used to convert the parsed value to a specific type.\r\n * @callback PropertyParser~convert\r\n * @param {*} value\r\n * @param {PropertyParser} [propertyParser]\r\n * @returns {*}\r\n */\r\n/**\r\n * The configuration for parsing a property from an object.\r\n * @typedef {object} PropertyParser~Configuration\r\n * @property {string} name - The name of the property as it appears in the resulting properties object.\r\n * @property {boolean} [required=false] - Whether or not this property is required. If set to true and the parsed value is null, undefined or the same as the defaultValue the item will fail to parse.\r\n * @property {boolean} [tracked=false] - Whether or not changes to this property are tracked. By default all required properties are tracked and will ignore this value.\r\n * @property {*} [defaultValue=null] - The default value returned for this property if none is parsed.\r\n * @property {PropertyParser~test} [test] - A method used to test the parsed value to check if it is valid. If not supplied the value is considered valid if: value != null && value !== defaultValue\r\n * @property {PropertyParser~convert} [convert] - A method used to convert the parsed value to a specific type.\r\n * @property {string} [queryParent=\"^\"]\r\n * @property {string} [queryPath=\"/\"]\r\n * @property {string} [queryType=\":\"]\r\n * @property {string[]} [obj=[]] - An array of queries used to parse a plain object reference for the property value. The properties are iterated in index order and the first match is returned.\r\n * @property {string[]} [elem=[]] - An array of queries used to parse an HTMLElement reference for the property value. The queries are iterated in index order and the first match is returned.\r\n */\r\n\r\n\r\n//endregion\r\n\r\nclass PropertyParser {\r\n\r\n    //#region static\r\n\r\n    /**\r\n     * The default convert method used by all properties. This does nothing but pass through the supplied value.\r\n     * @param {*} value - The parsed value.\r\n     * @param {PropertyParser} property - The property object itself.\r\n     * @returns {*}\r\n     */\r\n    static DEFAULT_CONVERT(value, property){\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * The default test method used by all properties to determine if the parsed value is valid.\r\n     * @param {*} value - The parsed value.\r\n     * @param {PropertyParser} property - The property object itself.\r\n     * @returns {boolean}\r\n     */\r\n    static DEFAULT_TEST(value, property){\r\n        return value != null && value !== property.defaultValue;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {propertyParserDefinition} configuration\r\n     * @returns {?PropertyParserDefinition}\r\n     */\r\n    static DEFINITION(configuration){\r\n        if (isPlainObject(configuration)){\r\n            return { configuration: /** @type PropertyParser~Configuration */ configuration, ctor: /** @type PropertyParser~ctor */ PropertyParser };\r\n        }\r\n        if (Array.isArray(configuration) && configuration.length === 2 && isPlainObject(configuration[0]) && isFunction(configuration[1])){\r\n            return { configuration: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Merges all property definitions from the source into the target, properties are compared by name.\r\n     * @param {propertyParserDefinition[]} target - The target array to push definitions into.\r\n     * @param {propertyParserDefinition[]} source - The source array to pull definitions from.\r\n     * @returns {propertyParserDefinition[]}\r\n     */\r\n    static MERGE_DEFINITIONS(target, source){\r\n        return mergeArray(target, source, (targetDefinition, sourceDefinition) => {\r\n            const targetDef = PropertyParser.DEFINITION(targetDefinition),\r\n                sourceDef = PropertyParser.DEFINITION(sourceDefinition);\r\n            if (!targetDef || !sourceDef) return false;\r\n            return targetDef.configuration.name === sourceDef.configuration.name;\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {TypeParser} typeParser\r\n     * @param {propertyParserDefinition} definition\r\n     * @returns {?PropertyParser}\r\n     */\r\n    static create(typeParser, definition){\r\n        const def = PropertyParser.DEFINITION(definition);\r\n        return def ? new def.ctor(typeParser, def.configuration) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {TypeParser} typeParser\r\n     * @param {propertyParserDefinition[]} propertyParserDefinitions\r\n     * @returns {PropertyParser[]}\r\n     */\r\n    static createAll(typeParser, propertyParserDefinitions){\r\n        return propertyParserDefinitions.reduce((result, definition) => {\r\n            const propertyParser = PropertyParser.create(typeParser, definition);\r\n            if (propertyParser) result.push(propertyParser);\r\n            return result;\r\n        },/** @type {PropertyParser[]} */ []);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} ref\r\n     * @param {PropertyParser[]} properties\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {?object}\r\n     */\r\n    static getValues(ref, properties, nocache){\r\n        const result = {};\r\n        for (const property of properties){\r\n            const value = property.getValue(ref, nocache);\r\n            if (property.required && !property.test(value)){\r\n                // if there is a required property that is not supplied then stop parsing and exit early\r\n                return null;\r\n            } else {\r\n                result[property.name] = value;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of a PropertyParser.\r\n     * @param {TypeParser} typeParser - The parent type parser for this instance.\r\n     * @param {PropertyParser~Configuration} configuration - The configuration for this instance.\r\n     */\r\n    constructor(typeParser, configuration) {\r\n        this.#typeParser = typeParser;\r\n        this.#name = configuration.name;\r\n        this.required = configuration.required ?? false;\r\n        this.defaultValue = configuration.defaultValue ?? null;\r\n        this.#convert = configuration.convert ?? PropertyParser.DEFAULT_CONVERT;\r\n        this.#test = configuration.test ?? PropertyParser.DEFAULT_TEST;\r\n        this.queryParent = configuration.queryParent ?? \"^\";\r\n        this.queryPath = configuration.queryPath ?? \"/\";\r\n        this.queryType = configuration.queryType ?? \":\";\r\n        if (Array.isArray(configuration.obj)){\r\n            this.obj = configuration.obj.map((query) => this.objectQuery(query)).filter((query) => query != null);\r\n        }\r\n        if (Array.isArray(configuration.elem)){\r\n            this.elem = configuration.elem.map((query) => this.elementQuery(query)).filter((query) => query != null);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region properties\r\n\r\n    /**\r\n     * The private field used by the 'typeParser' read-only property.\r\n     * @type {TypeParser}\r\n     * @private\r\n     */\r\n    #typeParser;\r\n    /**\r\n     * Get the parent type parser.\r\n     * @type {TypeParser}\r\n     * @readonly\r\n     */\r\n    get typeParser(){\r\n        return this.#typeParser;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the property was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Whether or not this property is required.\r\n     * @type {boolean}\r\n     * @default false\r\n     */\r\n    required;\r\n    /**\r\n     * The default value returned if none is parsed.\r\n     * @type {*}\r\n     * @default null\r\n     */\r\n    defaultValue;\r\n    /**\r\n     * The delimiter used by element queries to target a parent element.\r\n     * @type {string}\r\n     * @default \"^\"\r\n     */\r\n    queryParent;\r\n    /**\r\n     * The delimiter used by queries to target either a child element or object property.\r\n     * @type {string}\r\n     * @default \"/\"\r\n     */\r\n    queryPath;\r\n    /**\r\n     * The delimiter used by element queries to specify where the value should be pulled from.\r\n     * @type {string}\r\n     * @default \":\"\r\n     */\r\n    queryType;\r\n    /**\r\n     * An array of compiled queries used to interrogate plain objects.\r\n     * @type {ObjectQuery[]}\r\n     */\r\n    obj = [];\r\n    /**\r\n     * An array of compiled queries used to interrogate elements.\r\n     * @type {ElementQuery[]}\r\n     */\r\n    elem = [];\r\n    /**\r\n     * The method used to convert the parsed value to another type.\r\n     * @type {PropertyParser~convert}\r\n     * @default Property.DEFAULT_CONVERT\r\n     */\r\n    #convert;\r\n    /**\r\n     * The method used to test if the parsed value is valid.\r\n     * @type {PropertyParser~test}\r\n     * @default Property.DEFAULT_CONVERT\r\n     */\r\n    #test;\r\n    /**\r\n     *\r\n     * @type {Map<string, *>}\r\n     */\r\n    #cache = new Map();\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * @typedef {object} PropertyQuery\r\n     * @property {string} raw\r\n     * @property {string} name\r\n     * @property {function(*):*} getValue\r\n     */\r\n\r\n    /**\r\n     *\r\n     * @param {string} query\r\n     * @returns {?ObjectQuery}\r\n     */\r\n    objectQuery(query){\r\n        /**\r\n         * @typedef {PropertyQuery} ObjectQuery\r\n         * @property {string[]} path\r\n         */\r\n        if (isStringNotEmpty(query)){\r\n            let name = query, path = [];\r\n            if (name.indexOf(this.queryPath) !== -1){\r\n                const parts = name.split(this.queryPath);\r\n                name = parts.pop();\r\n                path.push(parts);\r\n            }\r\n            const target = (ref) => {\r\n                let result = ref;\r\n                for (const part of path){\r\n                    result = result[part];\r\n                    if (!result) break;\r\n                }\r\n                return result ?? null;\r\n            };\r\n            return {\r\n                raw: query,\r\n                name,\r\n                path,\r\n                getValue: (ref) => {\r\n                    const targetRef = target(ref);\r\n                    if (targetRef){\r\n                        return this.convert(targetRef[name]) ?? this.defaultValue;\r\n                    }\r\n                    return this.defaultValue;\r\n                }\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} query\r\n     * @returns {?ElementQuery}\r\n     */\r\n    elementQuery(query){\r\n        /**\r\n         * @typedef {PropertyQuery} ElementQuery\r\n         * @property {number} parents\r\n         * @property {?string} selector\r\n         */\r\n        if (isStringNotEmpty(query)){\r\n            let name = query, parents = 0, selector = null, type = \"prop\";\r\n            while(name[0] === this.queryParent){\r\n                parents++;\r\n                name = name.slice(1);\r\n            }\r\n            if (name.indexOf(this.queryPath) !== -1){\r\n                const parts = name.split(this.queryPath);\r\n                selector = parts[0];\r\n                name = parts[1];\r\n            }\r\n            if (name.indexOf(this.queryType) !== -1){\r\n                const parts = name.split(this.queryType);\r\n                type = parts[0];\r\n                name = parts[1];\r\n            }\r\n            const target = (ref) => {\r\n                let result = ref;\r\n                for (let i = 0; i < parents; i++){\r\n                    result = result.parentElement;\r\n                    if (!result) break;\r\n                }\r\n                return result && selector ? result.querySelector(selector) : result;\r\n            };\r\n            let getValue;\r\n            switch (type){\r\n                case \"prop\":\r\n                    getValue = (ref) => { return this.convert(ref[name]) ?? this.defaultValue; };\r\n                    break;\r\n                case \"data\":\r\n                    getValue = (ref) => { return this.convert(ref.dataset[name]) ?? this.defaultValue; };\r\n                    break;\r\n                case \"attr\":\r\n                    getValue = (ref) => { return ref.hasAttribute(name) ? this.convert(ref.getAttribute(name)) : this.defaultValue; };\r\n                    break;\r\n                default:\r\n                    getValue = () => this.defaultValue;\r\n                    break;\r\n            }\r\n            return {\r\n                raw: query,\r\n                name,\r\n                type,\r\n                parents,\r\n                selector,\r\n                getValue: (ref) => {\r\n                    const targetRef = target(ref);\r\n                    if (targetRef){\r\n                        return getValue(targetRef);\r\n                    }\r\n                    return this.defaultValue;\r\n                }\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param ref\r\n     * @param nocache\r\n     * @returns {*}\r\n     */\r\n    getValue(ref, nocache){\r\n        if (!nocache && this.#cache.has(ref)){\r\n            return this.#cache.get(ref);\r\n        }\r\n        let result = this.defaultValue;\r\n        if (ref instanceof HTMLElement){\r\n            for (const query of this.elem){\r\n                const value = query.getValue(ref);\r\n                if (this.test(value)){\r\n                    result = value;\r\n                    break;\r\n                }\r\n            }\r\n        } else if (isPlainObject(ref)){\r\n            for (const query of this.obj){\r\n                const value = query.getValue(ref);\r\n                if (this.test(value)){\r\n                    result = value;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.#cache.set(ref, result);\r\n        return result;\r\n    }\r\n\r\n    convert(value){\r\n        return this.#convert(value, this);\r\n    }\r\n\r\n    test(value){\r\n        return this.#test(value, this);\r\n    }\r\n}\r\n\r\nexport default PropertyParser;","import {isFunction} from \"./is\";\r\n\r\n/**\r\n * @template T\r\n * @param {Array<T>} target\r\n * @param {Array<T>} source\r\n * @param {function(T, T):boolean} [equalityComparer]\r\n * @returns {Array<T>}\r\n */\r\nfunction mergeArray(target, source, equalityComparer){\r\n    if (isFunction(equalityComparer)){\r\n        return [...target, ...source.filter((sourceValue) => !target.some((targetValue) => equalityComparer(targetValue, sourceValue)))];\r\n    }\r\n    return [...target, ...source.filter((targetValue) => !target.includes(targetValue))];\r\n}\r\n\r\nexport default mergeArray;","import {isFunction, isPlainObject, isStringNotEmpty} from \"../../../../../utils/is\";\r\nimport {defaults} from \"../../../../../utils/object\";\r\nimport makeSelector from \"../../../../../utils/makeSelector\";\r\nimport Item from \"../../Container/Item\";\r\nimport PropertyParser from \"./PropertyParser\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback TypeParser~ctor\r\n * @param {Parser} parser\r\n * @param {string} name\r\n * @returns TypeParser\r\n */\r\n/**\r\n * @typedef {object} TypeParserDefinition\r\n * @property {string} name\r\n * @property {TypeParser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default type parser is registered using the new name. If an array, the first element is the name, the second is the custom type parser constructor.\r\n * @typedef {string|[string,TypeParser~ctor]} typeParserDefinition\r\n */\r\n/**\r\n * The configuration for parsing an item from an object.\r\n * @typedef {object} TypeParser~Configuration\r\n * @property {number} [priority=0]\r\n * @property {string[]} [include]\r\n * @property {string[]} [exclude]\r\n * @property {propertyParserDefinition[]} [properties]\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Parses item data from various sources depending on configuration.\r\n */\r\nclass TypeParser {\r\n\r\n    //region static\r\n\r\n    /**\r\n     *\r\n     * @param {typeParserDefinition} configuration\r\n     * @returns {?TypeParserDefinition}\r\n     */\r\n    static DEFINITION(configuration){\r\n        if (isStringNotEmpty(configuration)){\r\n            return { name: /** @type string */ configuration, ctor: /** @type TypeParser~ctor */ TypeParser };\r\n        }\r\n        if (Array.isArray(configuration) && configuration.length === 2 && isStringNotEmpty(configuration[0]) && isFunction(configuration[1])){\r\n            return { name: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Parser} parser\r\n     * @param {typeParserDefinition} definition\r\n     * @returns {?TypeParser}\r\n     */\r\n    static create(parser, definition){\r\n        const def = TypeParser.DEFINITION(definition);\r\n        return def ? new def.ctor(parser, def.name) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Parser} parser\r\n     * @param {typeParserDefinition[]} typeParserDefinitions\r\n     * @returns {TypeParser[]}\r\n     */\r\n    static createAll(parser, typeParserDefinitions){\r\n        return typeParserDefinitions.reduce((result, config) => {\r\n            const typeParser = TypeParser.create(parser, config);\r\n            if (typeParser) result.push(typeParser);\r\n            return result;\r\n        },/** @type {TypeParser[]} */ []).sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Parses item data from various sources depending on configuration.\r\n     * @param {Parser} parser - The parent parser for this instance.\r\n     * @param {string} name - The type of item parsed by this instance.\r\n     */\r\n    constructor(parser, name) {\r\n        this.#parser = parser;\r\n        this.#name = name;\r\n        defaults(this.config, this.defaults);\r\n        this.#includeSelector = makeSelector(this.config.include);\r\n        this.#excludeSelector = makeSelector(this.config.exclude);\r\n        this.#properties = PropertyParser.createAll(this, PropertyParser.MERGE_DEFINITIONS(this.config.properties, this.parser.config.defaultProperties));\r\n        this.#requiredProperties = this.properties.filter((property) => property.required);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'parent' read-only property.\r\n     * @type {Parser}\r\n     * @private\r\n     */\r\n    #parser;\r\n    /**\r\n     * Get the parent parser.\r\n     * @type {Parser}\r\n     * @readonly\r\n     */\r\n    get parser(){\r\n        return this.#parser;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the type parser was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Get the default type parser configuration.\r\n     * @type {TypeParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get defaults(){\r\n        return {\r\n            priority: 0,\r\n            include: [],\r\n            exclude: [],\r\n            properties: [],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the parser configuration.\r\n     * @type {TypeParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if (isPlainObject(this.parser.config[this.name])){\r\n            return this.parser.config[this.name];\r\n        }\r\n        return this.parser.config[this.name] = {};\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'priority' read-only property.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    #priority;\r\n    /**\r\n     * Get the priority.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    get priority(){\r\n        return this.#priority;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'includeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #includeSelector;\r\n    /**\r\n     * Get the result of combining all configured include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get includeSelector(){\r\n        return this.#includeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'excludeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #excludeSelector;\r\n    /**\r\n     * Get the result of combining all configured exclude selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get excludeSelector(){\r\n        return this.#excludeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'properties' read-only property.\r\n     * @type {PropertyParser[]}\r\n     * @private\r\n     */\r\n    #properties;\r\n    /**\r\n     * Get all configured property parsers.\r\n     * @type {PropertyParser[]}\r\n     * @readonly\r\n     */\r\n    get properties(){\r\n        return this.#properties;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'requiredProperties' read-only property.\r\n     * @type {PropertyParser[]}\r\n     * @private\r\n     */\r\n    #requiredProperties;\r\n    /**\r\n     * Get all configured required property parsers.\r\n     * @type {PropertyParser[]}\r\n     * @readonly\r\n     */\r\n    get requiredProperties(){\r\n        return this.#requiredProperties;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Item>}\r\n     */\r\n    #cache = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #requiredPropertyCache = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #propertyCache = new Map();\r\n\r\n    //endregion\r\n\r\n    /**\r\n     * Checks if the supplied reference is included by this instance.\r\n     * NOTE: This DOES NOT check for exclusions! Use the canParse method if you want to check if a reference is both included AND NOT excluded.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    includes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.includeSelector !== null && ref.matches(this.includeSelector);\r\n        }\r\n        if (isPlainObject(ref)){\r\n            return ref.type === this.name;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference is excluded by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    excludes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.excludeSelector !== null && ref.matches(this.excludeSelector);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference can be parsed by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    canParse(ref) {\r\n        return this.includes(ref) && !this.excludes(ref);\r\n    }\r\n\r\n    create(parent, ref, trigger){\r\n        if (ref instanceof HTMLElement || isPlainObject(ref)){\r\n            return new Item(parent, this, ref, trigger);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new ParserItem.\r\n     * @param {Container} parent - The parent container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - Whether or not to ignore any cached values when parsing the item.\r\n     * @returns {?Item} Returns null if parsing fails.\r\n     */\r\n    parse(parent, ref, nocache){\r\n        let item;\r\n        if (this.#cache.has(ref)){\r\n            item = this.#cache.get(ref);\r\n        } else {\r\n            item = this.create(parent, ref, this.getTrigger(ref));\r\n        }\r\n        if (item instanceof Item){\r\n            const properties = this.getRequiredProperties(ref, nocache);\r\n            if (!properties){\r\n                this.#cache.delete(ref);\r\n                return null;\r\n            }\r\n            item.requiredProperties = properties;\r\n            this.#cache.set(ref, item);\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n     * Gets the trigger element for the reference object. Trigger elements are used to open the modal.\r\n     * @param {*} ref - The reference object to get the trigger from.\r\n     * @returns {?HTMLElement} Returns null if the item has no trigger element.\r\n     */\r\n    getTrigger(ref){\r\n        return ref instanceof HTMLElement ? ref : null;\r\n    }\r\n\r\n    getRequiredProperties(ref, nocache){\r\n        if (!nocache && this.#requiredPropertyCache.has(ref)){\r\n            return this.#requiredPropertyCache.get(ref);\r\n        }\r\n        const properties = PropertyParser.getValues(ref, this.requiredProperties, nocache);\r\n        this.#requiredPropertyCache.set(ref, properties);\r\n        return properties;\r\n    }\r\n\r\n    getProperties(ref, nocache){\r\n        if (!nocache && this.#propertyCache.has(ref)){\r\n            return this.#propertyCache.get(ref);\r\n        }\r\n        const properties = PropertyParser.getValues(ref, this.properties, nocache);\r\n        this.#propertyCache.set(ref, properties);\r\n        return properties;\r\n    }\r\n}\r\n\r\nexport default TypeParser;","import {extend} from \"../../../../utils/object\";\r\nimport {isNumber} from \"../../../../utils/is\";\r\n\r\n/**\r\n * A simple class containing the results of parsing a reference object.\r\n */\r\nclass Container {\r\n\r\n    /**\r\n     * A reference to the parser that produced this result.\r\n     * @type {Parser}\r\n     */\r\n    parser;\r\n\r\n    /**\r\n     * The reference object parsed.\r\n     * @type {*}\r\n     */\r\n    ref;\r\n\r\n    /**\r\n     * An object containing any parsed options.\r\n     * @type {object}\r\n     */\r\n    options;\r\n\r\n    /**\r\n     * @type {?EventTarget}\r\n     * @private\r\n     */\r\n    #triggerTarget = null;\r\n\r\n    /**\r\n     * An array of all parsed items.\r\n     * @type {Item[]}\r\n     */\r\n    items = [];\r\n\r\n    /**\r\n     * Create a new instance of the Container class.\r\n     * @param {Parser} parser - A reference to the parser that produced this container.\r\n     * @param {*} ref - The reference object parsed.\r\n     * @param {object} [options] - An object containing any parsed options.\r\n     * @param {?EventTarget} [triggerTarget] - The EventTarget instance that triggers the modal.\r\n     */\r\n    constructor(parser, ref, options, triggerTarget) {\r\n        this.parser = parser;\r\n        this.ref = ref;\r\n        this.options = extend({}, options);\r\n        if (triggerTarget instanceof EventTarget){\r\n            this.#triggerTarget = triggerTarget;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The EventTarget instance that triggers the modal.\r\n     * @returns {?EventTarget}\r\n     */\r\n    get triggerTarget(){\r\n        return this.#triggerTarget;\r\n    }\r\n\r\n    /**\r\n     * @param {EventTarget} value - The EventTarget instance to use as the trigger.\r\n     */\r\n    set triggerTarget(value){\r\n        if (value instanceof EventTarget){\r\n            this.#triggerTarget = value;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The Container.triggerTarget property must be an instance of EventTarget.\");\r\n    }\r\n\r\n    get firstIndex(){\r\n        return this.items.length ? 0 : -1;\r\n    }\r\n\r\n    get lastIndex(){\r\n        return this.items.length ? this.items.length - 1 : -1;\r\n    }\r\n\r\n    withinRange(index){\r\n        return isNumber(index) && index >= this.firstIndex && index <= this.lastIndex;\r\n    }\r\n\r\n    getByIndex(index){\r\n        return this.withinRange(index) ? this.items[index] : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {?Item}\r\n     */\r\n    getFirst(){\r\n        return this.firstIndex !== -1 ? this.items[this.firstIndex] : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {?Item}\r\n     */\r\n    getLast(){\r\n        return this.lastIndex !== -1 ? this.items[this.lastIndex] : null;\r\n    }\r\n\r\n    getNext(current, allowLoop){\r\n        const index = this.items.indexOf(current);\r\n        if (index !== -1){\r\n            let nextIndex = index + 1;\r\n            const withinRange = this.withinRange(nextIndex);\r\n            if (withinRange){\r\n                return this.items[nextIndex];\r\n            }\r\n            if (!withinRange && allowLoop){\r\n                return this.getFirst();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getPrevious(current, allowLoop){\r\n        const index = this.items.indexOf(current);\r\n        if (index !== -1){\r\n            let previousIndex = index - 1;\r\n            const withinRange = this.withinRange(previousIndex);\r\n            if (withinRange){\r\n                return this.items[previousIndex];\r\n            }\r\n            if (!withinRange && allowLoop){\r\n                return this.getLast();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    get [Symbol.toStringTag]() {\r\n        return \"Container\";\r\n    }\r\n}\r\n\r\nexport default Container;","/**\r\n *\r\n * @param {function} callback\r\n * @param {...*} [args]\r\n * @returns {Promise<*>}\r\n */\r\nasync function doCallback(callback, ...args){\r\n    return new Promise((resolve) => {\r\n        setTimeout(()=>{\r\n            resolve(callback(...args));\r\n        }, 0);\r\n    });\r\n}\r\n\r\n/**\r\n *\r\n * @param callback\r\n */\r\nfunction enqueue(callback){\r\n    setTimeout(callback, 0);\r\n}\r\n\r\n/**\r\n *\r\n * @template T\r\n * @param {Iterable<T>} iterable\r\n * @param {function(T)} callback\r\n * @returns {Promise<void>}\r\n */\r\nasync function asyncForEach(iterable, callback){\r\n    for (const i of iterable){\r\n        await doCallback(callback, i);\r\n    }\r\n}\r\n\r\nexport {\r\n    enqueue,\r\n    asyncForEach\r\n};","import {defaults, objReduce} from \"../../../../utils/object\";\r\nimport {isFunction, isPlainObject, isStringNotEmpty} from \"../../../../utils/is\";\r\nimport makeSelector from \"../../../../utils/makeSelector\";\r\nimport TypeParser from \"./TypeParser\";\r\nimport Container from \"../Container\";\r\nimport Emitter from \"../../../../utils/Emitter\";\r\nimport {asyncForEach} from \"../../../../utils/iasync\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback Parser~ctor\r\n * @param {ContainerController} containers\r\n * @param {string} name\r\n * @returns Parser\r\n */\r\n/**\r\n * @typedef {object} ParserDefinition\r\n * @property {string} name\r\n * @property {Parser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default parser is registered using the new name. If an array, the first element is the name, the second is the custom parser constructor.\r\n * @typedef {string|[string,Parser~ctor]} parserDefinition\r\n */\r\n/**\r\n * @typedef {object} Parser~Configuration\r\n * @property {typeParserDefinition[]} [__types__]\r\n * @property {number} [priority=49]\r\n * @property {string[]} [include]\r\n * @property {string[]} [exclude]\r\n * @property {{options:?string,items:?string}} [data]\r\n * @property {propertyParserDefinition[]} [defaultProperties]\r\n */\r\n/**\r\n * @typedef {object} ParserChange\r\n * @property {Item[]} added\r\n * @property {Item[]} removed\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * The base parser class.\r\n * @class\r\n */\r\nclass Parser extends Emitter {\r\n\r\n    //region static\r\n\r\n    /**\r\n     * @param {parserDefinition} configuration\r\n     * @returns {?ParserDefinition}\r\n     */\r\n    static DEFINITION(configuration){\r\n        if (isStringNotEmpty(configuration)){\r\n            return { name: /** @type string */ configuration, ctor: /** @type Parser~ctor */ Parser };\r\n        }\r\n        if (Array.isArray(configuration) && configuration.length === 2 && isStringNotEmpty(configuration[0]) && isFunction(configuration[1])){\r\n            return { name: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {ContainerController} containers\r\n     * @param {parserDefinition} definition\r\n     * @returns {?Parser}\r\n     */\r\n    static create(containers, definition){\r\n        const def = Parser.DEFINITION(definition);\r\n        return def ? new def.ctor(containers, def.name) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {ContainerController} containers\r\n     * @param {parserDefinition[]} parserDefinitions\r\n     * @returns {Parser[]}\r\n     */\r\n    static createAll(containers, parserDefinitions){\r\n        return parserDefinitions.reduce((result, config) => {\r\n            const parser = Parser.create(containers, config);\r\n            if (parser) result.push(parser);\r\n            return result;\r\n        },/** @type {Parser[]} */ []).sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of the Parser class.\r\n     * @param {ContainerController} containers - The parent for this instance.\r\n     * @param {string} name - The name the parser was registered with.\r\n     */\r\n    constructor(containers, name) {\r\n        super({bubbles: true}, containers);\r\n        this.#containers = containers;\r\n        this.#name = name;\r\n        defaults(this.config, this.defaults);\r\n        this.#priority = this.config.priority;\r\n        this.#includeSelector = makeSelector(this.config.include);\r\n        this.#excludeSelector = makeSelector(this.config.exclude);\r\n        this.#types = TypeParser.createAll(this, this.config.__types__);\r\n        this.#typesSelector = makeSelector(this.#types.map((type) => type.includeSelector));\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'containers' read-only property.\r\n     * @type {ContainerController}\r\n     * @private\r\n     */\r\n    #containers;\r\n    /**\r\n     * Get the containers controller for the parser.\r\n     * @type {ContainerController}\r\n     * @readonly\r\n     */\r\n    get containers(){\r\n        return this.#containers;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the parser was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Get the default parser configuration.\r\n     * @type {Parser~Configuration}\r\n     * @readonly\r\n     */\r\n    get defaults(){\r\n        return {\r\n            __types__: [],\r\n            priority: 49,\r\n            include: [],\r\n            exclude: [],\r\n            data: {\r\n                options: \"foobox\",\r\n                items: \"fooboxItems\",\r\n            },\r\n            defaultProperties: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the parser configuration.\r\n     * @type {Parser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if (isPlainObject(this.containers.config[this.name])){\r\n            return this.containers.config[this.name];\r\n        }\r\n        return this.containers.config[this.name] = {};\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'priority' read-only property.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    #priority;\r\n    /**\r\n     * Get the priority.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    get priority(){\r\n        return this.#priority;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'includeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #includeSelector;\r\n    /**\r\n     * Get the result of combining all configured include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get includeSelector(){\r\n        return this.#includeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'excludeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #excludeSelector;\r\n    /**\r\n     * Get the result of combining all configured exclude selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get excludeSelector(){\r\n        return this.#excludeSelector;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {TypeParser[]}\r\n     */\r\n    #types = [];\r\n\r\n    /**\r\n     * The private field used by the 'typesSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #typesSelector;\r\n    /**\r\n     * Get the result of combining all configured type parser include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get typesSelector(){\r\n        return this.#typesSelector;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Container>}\r\n     */\r\n    #containerCache = new Map();\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #dataCache = new Map();\r\n\r\n    /**\r\n     * Whether or not the parseDocument method should be called.\r\n     * @type {boolean}\r\n     * @readonly\r\n     */\r\n    get isDocumentParser(){ return true; }\r\n\r\n    //endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Checks if the supplied reference is included by this instance.\r\n     * NOTE: This DOES NOT check for exclusions! Use the canParse method if you want to check if a reference is both included AND NOT excluded.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    includes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.includeSelector !== null && ref.matches(this.includeSelector);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference is excluded by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    excludes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.excludeSelector !== null && ref.matches(this.excludeSelector);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference can be parsed by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    canParse(ref){\r\n        return this.includes(ref) && !this.excludes(ref);\r\n    }\r\n\r\n    /**\r\n     * Gets any configured data for an element reference.\r\n     * @param {HTMLElement} ref\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {Object}\r\n     */\r\n    data(ref, nocache){\r\n        if (!nocache && this.#dataCache.has(ref)){\r\n            return this.#dataCache.get(ref);\r\n        }\r\n        const dataConfig = this.config.data;\r\n        const result = objReduce(dataConfig, (result, dataName, key) => {\r\n            if (isStringNotEmpty(dataName) && ref.dataset.hasOwnProperty(dataName)){\r\n                let data;\r\n                try {\r\n                    data = JSON.parse(ref.dataset[dataName]);\r\n                } catch (err) {\r\n                    console.error(`Invalid dataset.${dataName} JSON string supplied.`, ref.dataset, dataName, err);\r\n                    data = null; // cache a null for errors so they will only be triggered again when the cache is flushed\r\n                } finally {\r\n                    result[key] = data;\r\n                }\r\n            } else {\r\n                result[key] = null;\r\n            }\r\n            return result;\r\n        }, {});\r\n        this.#dataCache.set(ref, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Parses the document and returns an array of new Containers.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Promise<Container[]>}\r\n     */\r\n    async parseDocument(handledRefs, nocache){\r\n        const results = [];\r\n        for (const selector of this.config.include){\r\n            await asyncForEach(document.querySelectorAll(selector), (ref) => {\r\n                if (handledRefs.has(ref) || this.excludes(ref)) return;\r\n                const container = this.parse(ref, handledRefs, nocache);\r\n                if (!container) return;\r\n                results.push(container);\r\n                handledRefs.add(ref);\r\n            });\r\n        }\r\n        this.purgeCache(results);\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Purges the internal cache given the results of the last parseDocument call.\r\n     * @param {Container[]} results\r\n     */\r\n    purgeCache(results){\r\n        for (const container of this.#containerCache.values()){\r\n            if (!results.includes(container) || this.shouldPurge(container)){\r\n                this.#containerCache.delete(container.ref);\r\n                this.trigger(\"removed-container\", [container]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a container should be purged from cache.\r\n     * @param {Container} container\r\n     * @returns {boolean}\r\n     */\r\n    shouldPurge(container){\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} ref\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {{itemRefs:Iterable, options:object, trigger:?EventTarget}}\r\n     */\r\n    getArgs(ref, nocache){\r\n        let trigger = null, itemRefs = [], options = {};\r\n        if (ref instanceof HTMLElement){\r\n            const data = this.data(ref, nocache);\r\n            if (isPlainObject(data.options)){\r\n                options = data.options;\r\n            }\r\n            if (Array.isArray(data.items)){\r\n                trigger = ref;\r\n                itemRefs.push(...data.items);\r\n            } else {\r\n                if (ref.matches(this.typesSelector)){\r\n                    itemRefs.push(ref);\r\n                }\r\n                itemRefs.push(...ref.querySelectorAll(this.typesSelector));\r\n            }\r\n        }\r\n        return { options, itemRefs, trigger };\r\n    }\r\n\r\n    /**\r\n     * Create a new container\r\n     * @param {*} ref\r\n     * @param {object} [options]\r\n     * @param {?EventTarget} [trigger]\r\n     * @returns {?Container}\r\n     */\r\n    create(ref, options, trigger){\r\n        if (ref instanceof HTMLElement){\r\n            return new Container(this, ref, options, trigger);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new Container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {?Container}\r\n     */\r\n    parse(ref, handledRefs, nocache){\r\n        const { itemRefs, options, trigger } = this.getArgs(ref, nocache);\r\n        let container, cached = false;\r\n        if (this.#containerCache.has(ref)){\r\n            container = this.#containerCache.get(ref);\r\n            cached = true;\r\n        } else {\r\n            container = this.create(ref, options, trigger);\r\n        }\r\n        if (container instanceof Container){\r\n            const items = this.parseItems(container, itemRefs, handledRefs, nocache);\r\n            if (cached){\r\n                // compare items\r\n                const changes = this.compareItems(items, container.items);\r\n                container.items.length = 0;\r\n                container.items.push(...items);\r\n                if (changes.added.length > 0 || changes.removed.length > 0){\r\n                    this.trigger(\"updated-container\", [container, changes]);\r\n                }\r\n            } else {\r\n                container.items.push(...items);\r\n                this.trigger(\"added-container\", [container]);\r\n            }\r\n            this.#containerCache.set(ref, container);\r\n        }\r\n        return container;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied iterable collection of objects and returns an array of new ContainerItems.\r\n     * @param {Container} parent - The parent container for the items.\r\n     * @param {Iterable} refs - An iterable collection of reference objects to parse.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Item[]}\r\n     */\r\n    parseItems(parent, refs, handledRefs, nocache){\r\n        const results = [];\r\n        for (const ref of refs){\r\n            if (handledRefs.has(ref) || this.excludes(ref)) continue;\r\n            const item = this.parseItem(parent, ref, nocache);\r\n            if (!item) continue;\r\n            results.push(item);\r\n            handledRefs.add(ref);\r\n        }\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new ContainerItem.\r\n     * @param {Container} parent - The parent container for the item.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {?Item} Returns null if parsing fails or no type can parse the reference object.\r\n     */\r\n    parseItem(parent, ref, nocache){\r\n        const type = this.#types.find((type) => type.canParse(ref));\r\n        return type ? type.parse(parent, ref, nocache) : null;\r\n    }\r\n\r\n    /**\r\n     * Compares a containers current items against its cached items and reports any changes.\r\n     * @param {Item[]} current\r\n     * @param {Item[]} cached\r\n     * @returns {ParserChange}\r\n     */\r\n    compareItems(current, cached){\r\n        const removed = cached.filter((item) => !current.includes(item));\r\n        const added = current.filter((item) => !cached.includes(item));\r\n        return { removed, added };\r\n    }\r\n\r\n    //endregion\r\n}\r\n\r\nexport default Parser;","import containers from \"./ContainerController/config\";\r\n\r\nexport default {\r\n    containers\r\n};","import parser_config from \"./Parser/config\";\r\nimport groups_config from \"./GroupParser/config\";\r\nimport GroupParser from \"./GroupParser\";\r\n\r\nexport default {\r\n    __parsers__: [\"default\", [\"groups\", GroupParser]],\r\n    default: parser_config,\r\n    groups: groups_config\r\n};","import {extend} from \"../../../../utils/object\";\r\nimport {isStringNotEmpty} from \"../../../../utils/is\";\r\nimport Parser from \"../Parser\";\r\nimport Container from \"../Container\";\r\nimport {asyncForEach} from \"../../../../utils/iasync\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {Parser~Configuration} GroupParser~Configuration\r\n * @property {number} [priority=99]\r\n */\r\n\r\n//endregion\r\n\r\nclass GroupParser extends Parser {\r\n\r\n    /**\r\n     * Get the parser configuration.\r\n     * @type {GroupParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        return super.config;\r\n    }\r\n\r\n    /**\r\n     * The default configuration.\r\n     * @returns {GroupParser~Configuration}\r\n     */\r\n    get defaults(){\r\n        return extend(super.defaults, {\r\n            priority: 99\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    async parseDocument(handledRefs, nocache) {\r\n        const results = [];\r\n        await asyncForEach(this.config.include, (selector) => {\r\n            if (!handledRefs.has(selector)){\r\n                const container = this.parse(selector, handledRefs, nocache);\r\n                if (container && container.items.length){\r\n                    results.push(container);\r\n                    handledRefs.add(selector);\r\n                }\r\n            }\r\n        });\r\n        this.purgeCache(results);\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    shouldPurge(container) {\r\n        return container.items.length === 0;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    create(ref, options, trigger){\r\n        if (isStringNotEmpty(ref)){\r\n            return new Container(this, ref, options, trigger);\r\n        }\r\n        return super.create(ref, options, trigger);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    getArgs(ref, nocache) {\r\n        if (isStringNotEmpty(ref)){\r\n            return { trigger: null, options: {}, itemRefs: document.querySelectorAll(ref) };\r\n        }\r\n        return super.getArgs(ref, nocache);\r\n    }\r\n\r\n}\r\n\r\nexport default GroupParser;","import * as is from \"./is\";\r\nimport * as obj from \"./object\"\r\n\r\nexport default {\r\n    is,\r\n    obj\r\n};","import Plugin from \"./Plugin\";\r\nimport defaults from \"./config\";\r\nimport ContainerController from \"./ContainerController\";\r\n// import ModalController from \"./controllers/ModalController\";\r\n\r\nimport utils from \"../../utils\";\r\n\r\nconst plugin = new Plugin(defaults, ContainerController);\r\nplugin.utils = utils;\r\n\r\nglobal.FooBox = plugin;\r\n\r\nexport default plugin;","import {extend} from \"../../utils/object\";\r\nimport {isNumber, isString} from \"../../utils/is\";\r\nimport Emitter from \"../../utils/Emitter\";\r\n\r\nimport startTask from \"../../utils/task\";\r\n/**\r\n * @extends Emitter\r\n */\r\nclass Plugin extends Emitter {\r\n\r\n    /**\r\n     *\r\n     * @type {object}\r\n     */\r\n    config = {};\r\n\r\n    constructor(defaults, ContainerController) {\r\n        super();\r\n        this.config = defaults;\r\n        this.#containers = new ContainerController(this, \"containers\");\r\n        // this.#modals = new ModalController(this);\r\n    }\r\n\r\n    //region Controllers\r\n\r\n    /**\r\n     * The private field used by the 'containers' read-only property.\r\n     * @type {ContainerController}\r\n     * @private\r\n     */\r\n    #containers;\r\n\r\n    /**\r\n     * Get the containers for the plugin.\r\n     * @type {ContainerController}\r\n     * @readonly\r\n     */\r\n    get containers(){\r\n        return this.#containers;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'modals' read-only property.\r\n     * @type {ModalController}\r\n     * @private\r\n     */\r\n    #modals;\r\n\r\n    //endregion\r\n\r\n    //#region readyState\r\n\r\n    /**\r\n     * 0 - The plugin script has been evaluated but not yet initialized.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 0\r\n     */\r\n    get RS_DEFAULT(){ return 0; }\r\n\r\n    /**\r\n     * 1 - The configuration has been set but components have not been loaded yet.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 1\r\n     */\r\n    get RS_INITIALIZING(){ return 1; }\r\n\r\n    /**\r\n     * 2 - The components are loaded but long running tasks have not been run.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 2\r\n     */\r\n    get RS_INITIALIZED(){ return 2; }\r\n\r\n    /**\r\n     * 3 - Long running tasks have completed. The plugin is now ready.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 3\r\n     */\r\n    get RS_READY(){ return 3; }\r\n\r\n    /**\r\n     *\r\n     * @type {number}\r\n     */\r\n    #readyStateValue = this.RS_DEFAULT;\r\n\r\n    /**\r\n     * Get the current readyState\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 0\r\n     */\r\n    get readyState(){\r\n        return this.#readyStateValue;\r\n    }\r\n\r\n    /**\r\n     * Set the readyState value and trigger the \"readystatechange\" event.\r\n     * @private\r\n     * @param {number} value\r\n     * @fires Document#foobox-readystatechange\r\n     * @fires Plugin#readystatechange\r\n     * @throws {TypeError} Throws a TypeError if the value is not a number.\r\n     * @throws {RangeError} Throws a RangeError if the value is less than the current value or more than the RS_READY value.\r\n     */\r\n    set #readyState(value){\r\n        if (this.#readyStateValue === value) return; // do nothing\r\n        if (!isNumber(value)) throw new TypeError(\"The 'value' argument must be a number.\");\r\n        if (value < this.#readyStateValue) throw new RangeError(\"The 'value' argument can't be less than the current readyState.\");\r\n        if (value > this.RS_READY) throw new RangeError(\"The 'value' argument can't be more than the RS_READY value.\");\r\n        this.#readyStateValue = value;\r\n        /**\r\n         * Occurs whenever the readyState is changed.\r\n         * @event Document#foobox-readystatechange\r\n         * @param {CustomEvent} event - The readyState value can be accessed using the CustomEvent.detail property which is set to the plugin instance. e.g. event.detail.readyState\r\n         */\r\n        this.documentDispatch(\"foobox-readystatechange\");\r\n        /**\r\n         * Occurs whenever the readyState is changed.\r\n         * @event Plugin#readystatechange\r\n         * @param {EmitterEvent} event - The basic event object.\r\n         * @param {number} readyState - The readyState value.\r\n         */\r\n        this.trigger(\"readystatechange\", [value]);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Dispatch an event on the document.\r\n     * @param {string|Event} event - If given a string a CustomEvent is dispatched using the value as the type.\r\n     * @param {eventOptions} [options] - Any additional options for the event. By default the detail option of CustomEvent objects created by this method is set to the plugin instance.\r\n     * @returns {boolean}\r\n     */\r\n    documentDispatch(event, options){\r\n        /** @typedef {{bubbles:?boolean,cancelable:?boolean,composed:?boolean,detail:*}} eventOptions */\r\n        if (isString(event)){\r\n            event = new CustomEvent(event, extend({ detail: this }, options));\r\n        }\r\n        if (event instanceof Event){\r\n            return document.dispatchEvent(event);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param configuration\r\n     */\r\n    async init( configuration ) {\r\n        if ( this.readyState !== this.RS_DEFAULT ) return;\r\n        const task = startTask( 'foobox:init()' );\r\n        extend( this.config, configuration );\r\n        this.#readyState = this.RS_INITIALIZING;\r\n        this.#containers.init();\r\n        this.#readyState = this.RS_INITIALIZED;\r\n        await this.#containers.parseDocument( true );\r\n        this.#readyState = this.RS_READY;\r\n        task.end();\r\n    }\r\n\r\n    registerParser(name, configuration, ctor){\r\n        return this.#containers.registerParser(name, configuration, ctor);\r\n    }\r\n\r\n    async parseDocument(nocache){\r\n        return await this.#containers.parseDocument(nocache);\r\n    }\r\n\r\n    parse(ref, nocache){\r\n        return this.#containers.parse(ref, nocache);\r\n    }\r\n}\r\n\r\nexport default Plugin;","import {defaults, extend} from \"../../../utils/object\";\r\nimport {asyncForEach} from \"../../../utils/iasync\";\r\nimport {isFunction, isPlainObject} from \"../../../utils/is\";\r\nimport Parser from \"./Parser\";\r\nimport Emitter from \"../../../utils/Emitter\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {object} ContainerController~Configuration\r\n * @property {parserDefinition[]} [__parsers__]\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new instance of the ContainerController.\r\n * @extends Emitter\r\n * @param {Plugin} parent - A reference to the parent plugin controller.\r\n */\r\nclass ContainerController extends Emitter {\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of the ContainerController.\r\n     * @constructs\r\n     * @param {Plugin} plugin - A reference to the parent plugin controller.\r\n     * @param {string} name - The name the containers were registered with.\r\n     */\r\n    constructor(plugin, name) {\r\n        super({bubbles: true}, plugin);\r\n        this.#plugin = plugin;\r\n        this.#name = name;\r\n        defaults(this.config, this.defaults);\r\n        this.on({\r\n            \"added-container\": this.#onAddedContainer,\r\n            \"removed-container\": this.#onRemovedContainer,\r\n            \"updated-container\": this.#onUpdatedContainer\r\n        }, this);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n\r\n    /**\r\n     * Get the name of the component.\r\n     * @type {string}\r\n     * @readonly\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'plugin' read-only property.\r\n     * @type {Plugin}\r\n     * @private\r\n     */\r\n    #plugin;\r\n\r\n    /**\r\n     * Get the plugin instance.\r\n     * @type {Plugin}\r\n     * @readonly\r\n     */\r\n    get plugin(){\r\n        return this.#plugin;\r\n    }\r\n\r\n    /**\r\n     * Get the default containers configuration.\r\n     * @type {ContainerController~Configuration}\r\n     * @readonly\r\n     */\r\n    get defaults(){\r\n        return {\r\n            __parsers__: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the containers configuration.\r\n     * @type {ContainerController~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if (isPlainObject(this.plugin.config[this.name])){\r\n            return this.plugin.config[this.name];\r\n        }\r\n        return this.plugin.config[this.name] = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Container>}\r\n     */\r\n    #containers = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<EventTarget, EventListener>}\r\n     */\r\n    #triggers = new Map();\r\n\r\n    /**\r\n     * Used to ensure multiple calls to the parseDocument method during parsing all return the same result instead of simply kicking off multiple parses.\r\n     * @type {Promise<Container[]>}\r\n     * @private\r\n     */\r\n    #parseDocument = null;\r\n\r\n    /**\r\n     *\r\n     * @type {Parser[]}\r\n     */\r\n    #parsers = [];\r\n\r\n    /**\r\n     *\r\n     * @type {Parser[]}\r\n     * @readonly\r\n     */\r\n    get __parsers__(){\r\n        return this.#parsers;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Initializes the container controller.\r\n     */\r\n    init(){\r\n        if (this.plugin.readyState !== this.plugin.RS_INITIALIZING) return;\r\n        this.#parsers = Parser.createAll(this, this.config.__parsers__);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @param {object} [configuration]\r\n     * @param {Parser~ctor} [ctor]\r\n     * @returns {boolean}\r\n     */\r\n    registerParser(name, configuration, ctor){\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED && !this.config.hasOwnProperty(name)){\r\n            const Parser_ctor = isFunction(ctor) ? ctor : Parser;\r\n            this.config.__parsers__.push([name, Parser_ctor]);\r\n            this.config[name] = extend({}, configuration);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @returns {boolean}\r\n     */\r\n    unregisterParser(name){\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED && this.config.hasOwnProperty(name)){\r\n            this.config.__parsers__ = this.config.__parsers__.filter((config) => {\r\n                const parser = Parser.DEFINITION(config);\r\n                return parser ? parser.name !== name : false;\r\n            });\r\n            delete this.config[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Remove any trigger listeners registered using the addTrigger method.\r\n     * @param {?EventTarget} eventTarget\r\n     */\r\n    removeTriggerListener(eventTarget){\r\n        if (eventTarget instanceof EventTarget && this.#triggers.has(eventTarget)){\r\n            const listener = this.#triggers.get(eventTarget);\r\n            eventTarget.removeEventListener(\"click\", listener, false);\r\n            this.#triggers.delete(eventTarget);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up a trigger listener on the target.\r\n     * @param {?EventTarget} eventTarget\r\n     * @param {Container} container\r\n     * @param {?Item} [item]\r\n     */\r\n    addTriggerListener(eventTarget, container, item){\r\n        if (eventTarget instanceof EventTarget){\r\n            if (this.#triggers.has(eventTarget)){\r\n                // if there was a listener already cached then remove it before adding the new one\r\n                eventTarget.removeEventListener(\"click\", this.#triggers.get(eventTarget), false);\r\n            }\r\n            const listener = (e) => {\r\n                e.preventDefault();\r\n                this.trigger(\"triggered-container\", [container, item]);\r\n            };\r\n            // add the listener to the internal cache, this will update the listener if it existed\r\n            this.#triggers.set(eventTarget, listener);\r\n            eventTarget.addEventListener(\"click\", listener, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all document parsers.\r\n     * @returns {Parser[]}\r\n     */\r\n    getDocumentParsers(){\r\n        return this.#parsers.filter((parser) => parser.isDocumentParser);\r\n    }\r\n\r\n    /**\r\n     * Try get a parser for the reference.\r\n     * @param {*} ref\r\n     * @returns {?Parser}\r\n     */\r\n    getRefParser(ref){\r\n        return this.#parsers.find((parser) => parser.canParse(ref)) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Get all containers for this instance of the plugin.\r\n     * @returns {Container[]}\r\n     */\r\n    getAll(){\r\n        return Array.from(this.#containers.values());\r\n    }\r\n\r\n    /**\r\n     * Get a collection of references from all containers and items.\r\n     * @param {*} excludeRef - A reference to exclude from the result.\r\n     * @returns {Set<*>}\r\n     */\r\n    getRefs(excludeRef){\r\n        /** @type {Set<*>} */\r\n        const refs = new Set();\r\n        return this.getAll().reduce((result, container) => {\r\n            if (container.ref !== excludeRef){\r\n                result.add(container.ref);\r\n                container.items.forEach((item) => {\r\n                    if (item.ref === excludeRef) return;\r\n                    result.add(item.ref);\r\n                });\r\n            }\r\n            return result;\r\n        }, refs);\r\n    }\r\n\r\n    /**\r\n     * Parses the entire document and returns an array of Container objects.\r\n     * @async\r\n     * @param {boolean} [nocache=false] - Whether or not to disable the parser cache for this call.\r\n     * @returns {Promise<Container[]>} Returns an empty array if no Containers were parsed.\r\n     */\r\n    async parseDocument(nocache){\r\n        // if the plugin is not initialized yet return an empty array as we have no parsers to work with\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED) return [];\r\n        // if there is already parsing taking place simply return a reference to its promise\r\n        if (this.#parseDocument) return this.#parseDocument;\r\n        // otherwise we need to do some work\r\n        nocache = nocache ?? false;\r\n        return this.#parseDocument = new Promise(async (resolve) => {\r\n            const results = [], handledRefs = new Set();\r\n            await asyncForEach(this.getDocumentParsers(), async (parser) => {\r\n                const containers = await parser.parseDocument(handledRefs, nocache);\r\n                results.push(...containers);\r\n            });\r\n            this.#parseDocument = null;\r\n            resolve(results);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parse the supplied reference object into a Container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - Whether or not to disable the parser caching for this call.\r\n     * @returns {?Container} Returns null if the reference object could not be parsed.\r\n     */\r\n    parse(ref, nocache){\r\n        if (this.plugin.readyState < this.plugin.RS_INITIALIZED) return null;\r\n        nocache = nocache ?? false;\r\n        const parser = this.getRefParser(ref);\r\n        if (parser){\r\n            const handledRefs = this.getRefs(ref);\r\n            return parser.parse(ref, handledRefs, nocache);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region listeners\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     */\r\n    #onAddedContainer(event, container){\r\n        this.addTriggerListener(container.triggerTarget, container);\r\n        container.items.forEach((item) => this.addTriggerListener(item.triggerTarget, container, item));\r\n        this.#containers.set(container.ref, container);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     * @param {ParserChange} changes\r\n     */\r\n    #onUpdatedContainer(event, container, changes){\r\n        changes.removed.forEach((item) => this.removeTriggerListener(item.triggerTarget));\r\n        changes.added.forEach((item) => this.addTriggerListener(item.triggerTarget, container, item));\r\n        this.#containers.set(container.ref, container);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     */\r\n    #onRemovedContainer(event, container){\r\n        this.removeTriggerListener(container.triggerTarget);\r\n        container.items.forEach((item) => this.removeTriggerListener(item.triggerTarget));\r\n        this.#containers.delete(container.ref);\r\n    }\r\n\r\n    //endregion\r\n}\r\n\r\nexport default ContainerController;","/**\r\n * Check if the value is a boolean.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isBoolean(value){\r\n    return value != null && '[object Boolean]' === Object.prototype.toString.call(value);\r\n}\r\n\r\n/**\r\n * Check if the value is a function.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isFunction(value){\r\n    return value != null && (Object.prototype.toString.call(value) === \"[object Function]\" || typeof value === \"function\" || value instanceof Function);\r\n}\r\n\r\n/**\r\n * Check if the value is a number.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isNumber(value){\r\n    return value != null && '[object Number]' === Object.prototype.toString.call(value) && !isNaN(value);\r\n}\r\n\r\n/**\r\n * Check if the value is an object.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isObject(value){\r\n    return value != null && typeof value === \"object\";\r\n}\r\n\r\n/**\r\n * Check if the value is a plain object.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isPlainObject(value){\r\n    if (isObject(value)){\r\n        const proto = Object.getPrototypeOf(value);\r\n        return proto === Object.prototype || proto === null;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Check if the value is a promise.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isPromise(value){\r\n    return value != null && value instanceof Promise;\r\n}\r\n\r\n/**\r\n * Check if the value is a string.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isString(value){\r\n    return value != null && '[object String]' === Object.prototype.toString.call(value);\r\n}\r\n\r\nconst isEmptyString = /^\\s*$/;\r\n/**\r\n * Check if the value is a string and is not empty.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isStringNotEmpty(value){\r\n    return isString(value) && !isEmptyString.test(value);\r\n}\r\n\r\n/**\r\n * Check if the value is a undefined.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isUndefined(value){\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport {\r\n    isBoolean,\r\n    isFunction,\r\n    isNumber,\r\n    isObject,\r\n    isPlainObject,\r\n    isPromise,\r\n    isString,\r\n    isStringNotEmpty,\r\n    isUndefined\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t958: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkfoobox\"] = self[\"webpackChunkfoobox\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(419);\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","hasProperty","target","propertyName","isPlainObject","isStringNotEmpty","indexOf","hasOwnProperty","names","split","length","last","index","currentTarget","name","removeProperty","getProperty","defaultValue","setProperty","value","isUndefined","merge","source","objForEach","key","Array","isArray","slice","extend","sources","reduce","result","mergeMissing","missing","defaults","callback","Object","keys","forEach","call","this","objReduce","callbackFn","initialValue","previousValue","constructor","type","options","parsed","Emitter","namespace","isBoolean","bubbles","cancelable","defaultPrevented","emitterInstance","TypeError","currenTarget","preventDefault","isDefaultPrevented","stopPropagation","isPropagationStopped","static","required","parsedType","n_index","EVENT_TYPE_NAMESPACE_SEPARATOR","parentEmitter","Map","__events__","__emitterEventDefaults__","__parentEmitter__","listener","thisArg","isFunction","eventType","parseType","namespaces","get","set","listeners","thisArgs","Set","add","types","push","has","delete","size","args","on","typeOrTypeMap","typeListenerOrTypeMapThisArg","typeThisArg","arguments","off","emit","event","EmitterEvent","trigger","map","every","success","arrow","color","indent","style","backgroundColor","__types__","include","exclude","defaultProperties","obj","elem","test","image","priority","iframe","filter","val","join","parent","ref","requiredProperties","triggerTarget","EventTarget","getProperties","nocache","PropertyParser","property","configuration","ctor","equalityComparer","sourceValue","some","targetValue","includes","mergeArray","targetDefinition","sourceDefinition","targetDef","DEFINITION","sourceDef","typeParser","definition","def","propertyParserDefinitions","propertyParser","create","properties","getValue","convert","DEFAULT_CONVERT","DEFAULT_TEST","queryParent","queryPath","queryType","query","objectQuery","elementQuery","path","parts","pop","part","raw","targetRef","parents","selector","i","parentElement","querySelector","dataset","hasAttribute","getAttribute","HTMLElement","TypeParser","parser","typeParserDefinitions","config","sort","a","b","makeSelector","includeSelector","excludeSelector","matches","excludes","canParse","Item","parse","item","getTrigger","getRequiredProperties","Container","items","firstIndex","lastIndex","withinRange","isNumber","getByIndex","getFirst","getLast","getNext","current","allowLoop","nextIndex","getPrevious","previousIndex","toStringTag","Symbol","async","doCallback","Promise","resolve","setTimeout","asyncForEach","iterable","Parser","containers","parserDefinitions","super","data","typesSelector","isDocumentParser","dataName","JSON","err","console","error","handledRefs","results","document","querySelectorAll","container","purgeCache","values","shouldPurge","getArgs","itemRefs","cached","parseItems","changes","compareItems","added","removed","refs","parseItem","find","__parsers__","default","parser_config","groups","groups_config","is","plugin","ContainerController","RS_DEFAULT","RS_INITIALIZING","RS_INITIALIZED","RS_READY","readyState","RangeError","documentDispatch","isString","CustomEvent","detail","Event","dispatchEvent","task","startTime","performance","now","startFormat","debug","end","duration","diff","start","endFormat","toFixed","startTask","init","parseDocument","registerParser","Parser_ctor","unregisterParser","removeTriggerListener","eventTarget","removeEventListener","addTriggerListener","e","addEventListener","getDocumentParsers","getRefParser","getAll","from","getRefs","excludeRef","utils","global","FooBox","prototype","toString","Function","isNaN","isObject","proto","getPrototypeOf","isPromise","isEmptyString","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","O","chunkIds","fn","notFulfilled","Infinity","fulfilled","j","splice","r","d","o","defineProperty","enumerable","g","globalThis","window","prop","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","id","chunkLoadingGlobal","self","bind","__webpack_exports__"],"sourceRoot":""}