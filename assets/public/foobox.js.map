{"version":3,"file":"foobox.js","mappings":"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","sources":["webpack://foobox/webpack/runtime/chunk loaded","webpack://foobox/./src/utils/object.js","webpack://foobox/./src/utils/index.js","webpack://foobox/./src/utils/iasync.js","webpack://foobox/./src/utils/EmitterEvent.js","webpack://foobox/./src/utils/Emitter.js","webpack://foobox/./src/utils/makeSelector.js","webpack://foobox/./src/public/foobox/PropertyParser.js","webpack://foobox/./src/utils/mergeArray.js","webpack://foobox/./src/public/foobox/Item.js","webpack://foobox/./src/public/foobox/TypeParser.js","webpack://foobox/./src/public/foobox/Container.js","webpack://foobox/./src/public/foobox/Parser.js","webpack://foobox/./src/public/foobox/Plugin.js","webpack://foobox/./src/public/foobox/GroupParser.js","webpack://foobox/./src/public/foobox/index.js","webpack://foobox/./src/utils/is.js","webpack://foobox/webpack/bootstrap","webpack://foobox/webpack/runtime/define property getters","webpack://foobox/webpack/runtime/global","webpack://foobox/webpack/runtime/hasOwnProperty shorthand","webpack://foobox/webpack/runtime/make namespace object","webpack://foobox/webpack/runtime/jsonp chunk loading","webpack://foobox/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import {isPlainObject, isStringNotEmpty, isUndefined} from \"./is\";\r\n\r\nfunction hasProperty(target, propertyName){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    return currentTarget.hasOwnProperty(name);\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return target.hasOwnProperty(propertyName);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Remove a property from an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n */\r\nfunction removeProperty(target, propertyName){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    delete currentTarget[name];\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                }\r\n            }\r\n        } else {\r\n            delete target[propertyName];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get the value of a property from an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n * @param {*} [defaultValue]\r\n * @returns {*}\r\n */\r\nfunction getProperty(target, propertyName, defaultValue){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    if (currentTarget.hasOwnProperty(name)){\r\n                        return currentTarget[name];\r\n                    }\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n        } else if (target.hasOwnProperty(propertyName)){\r\n            return target[propertyName];\r\n        }\r\n    }\r\n    return defaultValue;\r\n}\r\n\r\n/**\r\n * Set the value of a property in an object.\r\n * @param {object} target\r\n * @param {string} propertyName\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction setProperty(target, propertyName, value){\r\n    if (isPlainObject(target) && isStringNotEmpty(propertyName) && !isUndefined(value)){\r\n        if (propertyName.indexOf(\".\") !== -1){\r\n            const names = propertyName.split(\".\"), length = names.length, last = length - 1;\r\n            let index = 0, currentTarget = target;\r\n            for (; index < length; index++){\r\n                const name = names[index];\r\n                if (index === last){\r\n                    currentTarget[name] = value;\r\n                    return true;\r\n                } else if (isPlainObject(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name];\r\n                } else if (isUndefined(currentTarget[name])) {\r\n                    currentTarget = currentTarget[name] = {};\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            target[propertyName] = value;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Merge the properties of the source object into the target object replacing existing values.\r\n * @param {object} target - The object that will receive the properties.\r\n * @param {object} source - The object to extract properties from.\r\n * @returns {object}\r\n */\r\nfunction merge(target, source) {\r\n    target = isPlainObject(target) ? target : {};\r\n    if (isPlainObject(target) && isPlainObject(source)){\r\n        objForEach(source, (key, value) => {\r\n            if (isPlainObject(value)){\r\n                // if the source value is an object, merge it into the target key\r\n                target[key] = merge(target[key], value);\r\n            } else if (Array.isArray(value)){\r\n                // if the source value is an array, replace the target key with a shallow copy of it\r\n                target[key] = value.slice();\r\n            } else {\r\n                // otherwise replace the target key with the source value\r\n                target[key] = value;\r\n            }\r\n        });\r\n    }\r\n    // always return the original target object\r\n    return target;\r\n}\r\n\r\n/**\r\n * Merge the properties of all source objects into the target object replacing existing values.\r\n * @param {object} target\r\n * @param {...object} sources\r\n * @returns {object}\r\n */\r\nfunction extend(target, ...sources) {\r\n    target = isPlainObject(target) ? target : {};\r\n    return sources.reduce((result, source) => merge(result, source), target);\r\n}\r\n\r\n/**\r\n * Merge the properties of the source object into the target object if they do not exist.\r\n * @param {object} target - The object that will receive the properties.\r\n * @param {object} source - The object to extract properties from.\r\n * @returns {object}\r\n */\r\nfunction mergeMissing(target, source){\r\n    target = isPlainObject(target) ? target : {};\r\n    if (isPlainObject(source)){\r\n        objForEach(source, (key, value) => {\r\n            const missing = !target.hasOwnProperty(key);\r\n            if (isPlainObject(value)){ // if the source value is an object\r\n                if (isPlainObject(target[key])){ // and the target key is an object, merge the missing source properties\r\n                    target[key] = mergeMissing(target[key], value);\r\n                } else if (missing) { // otherwise if its missing, set the target key to the source value\r\n                    target[key] = merge({}, value);\r\n                }\r\n            } else if (missing) {\r\n                // if its just missing and not a special case, set the target key with the missing source value\r\n                target[key] = value;\r\n            }\r\n        });\r\n    }\r\n    // always return the original target object\r\n    return target;\r\n}\r\n\r\n/**\r\n * Merge the properties of all source objects into the target object if they do not exist.\r\n * @param {object} target\r\n * @param {...object} sources\r\n * @returns {object}\r\n */\r\nfunction defaults(target, ...sources){\r\n    target = isPlainObject(target) ? target : {};\r\n    return sources.reduce((result, source) => mergeMissing(result, source), target);\r\n}\r\n\r\n/**\r\n * @callback objForEach~callback\r\n * @param {string} key\r\n * @param {*} value\r\n */\r\n\r\n/**\r\n * Iterates all keys of the target and executes the callback for each supplying the current key and value.\r\n * @param {object} target - The target object to iterate.\r\n * @param {objForEach~callback} callback - The callback to execute.\r\n */\r\nfunction objForEach(target, callback){\r\n    Object.keys(target).forEach((key) => {\r\n        callback.call(this, key, target[key]);\r\n    });\r\n}\r\n\r\n/**\r\n * A \"reducer\" function that can take up to four arguments.\r\n * @callback objReduce~callback\r\n * @template T\r\n * @param {T} previousValue - The value resulting from the previous call to the callback.\r\n * @param {*} value - The value of the current key.\r\n * @param {string} [key] - The current key of the object.\r\n * @param {object} [object] - The object being iterated.\r\n * @returns {T}\r\n */\r\n/**\r\n * The objReduce() method executes a user-supplied “reducer” callback function on each key~value pair of the target object,\r\n * passing in the return value from the calculation on the preceding pair. The final result of running the reducer across\r\n * all key~value pairs of the target object is a single value.\r\n * @template T\r\n * @param {object} target - The object to reduce.\r\n * @param {objReduce~callback<T>} callbackFn - A \"reducer\" function that takes four arguments.\r\n * @param {T} [initialValue] - A value to which \"previousValue\" is initialized the first time the callback is called.\r\n * @returns {T} The value that results from running the “reducer” callback function to completion over the entire object.\r\n */\r\nfunction objReduce(target, callbackFn, initialValue){\r\n    return Object.keys(target).reduce((previousValue, key) => {\r\n        return callbackFn.call(this, previousValue, target[key], key);\r\n    }, initialValue);\r\n}\r\n\r\nexport {\r\n    objForEach,\r\n    objReduce,\r\n    hasProperty,\r\n    removeProperty,\r\n    getProperty,\r\n    setProperty,\r\n    merge,\r\n    extend,\r\n    mergeMissing,\r\n    defaults\r\n};","import * as is from \"./is\";\r\nimport * as obj from \"./object\"\r\n\r\nexport default {\r\n    is,\r\n    obj\r\n};","/**\r\n *\r\n * @param {function} callback\r\n * @param {...*} [args]\r\n * @returns {Promise<*>}\r\n */\r\nasync function doCallback(callback, ...args){\r\n    return new Promise((resolve) => {\r\n        setTimeout(()=>{\r\n            resolve(callback(...args));\r\n        }, 0);\r\n    });\r\n}\r\n\r\n/**\r\n *\r\n * @param callback\r\n */\r\nfunction enqueue(callback){\r\n    setTimeout(callback, 0);\r\n}\r\n\r\n/**\r\n *\r\n * @template T\r\n * @param {Iterable<T>} iterable\r\n * @param {function(T)} callback\r\n * @returns {Promise<void>}\r\n */\r\nasync function asyncForEach(iterable, callback){\r\n    for (const i of iterable){\r\n        await doCallback(callback, i);\r\n    }\r\n}\r\n\r\nexport {\r\n    enqueue,\r\n    asyncForEach\r\n};","import {isBoolean, isPlainObject, isStringNotEmpty} from \"./is\";\r\nimport Emitter from \"./Emitter\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {object} EmitterEventOptions\r\n * @property {boolean} [bubbles=false] - Whether or not the event is bubbled.\r\n * @property {boolean} [cancelable=false] - Whether or not the event can be canceled using preventDefault.\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new EmitterEvent instance.\r\n * @class EmitterEvent\r\n * @param {string} type - The type of the event.\r\n * @param {EmitterEventOptions} [options] - The options for the event.\r\n * @param {Emitter} [target] - The target for the event.\r\n * @throws {TypeError} Throws a TypeError if the supplied `type` is invalid.\r\n */\r\nclass EmitterEvent {\r\n\r\n    //#region constructor\r\n\r\n    /**\r\n     * @constructs\r\n     * @param {string} type - The type of the event.\r\n     * @param {EmitterEventOptions} [options] - The options for the event.\r\n     * @param {Emitter} [target] - The target for the event.\r\n     * @throws {TypeError} Throws a TypeError if the supplied `type` is invalid.\r\n     */\r\n    constructor(type, options, target) {\r\n        const parsed = Emitter.parseType(type, true);\r\n        this.#type = parsed.type;\r\n        this.#namespace = parsed.namespace;\r\n        if (isPlainObject(options)){\r\n            this.#bubbles = isBoolean(options.bubbles) ? options.bubbles : false;\r\n            this.#cancelable = isBoolean(options.cancelable) ? options.bubbles : false;\r\n        }\r\n        if (target instanceof Emitter){\r\n            this.#target = this.#currenTarget = target;\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region properties\r\n\r\n    /**\r\n     * The private field used by the type read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #type;\r\n    /**\r\n     * The type of event.\r\n     * @type {string}\r\n     * @readonly\r\n     */\r\n    get type(){\r\n        return this.#type;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the namespace read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #namespace = null;\r\n    /**\r\n     * The namespace of the event.\r\n     * @type {?string}\r\n     * @readonly\r\n     * @default null\r\n     */\r\n    get namespace(){\r\n        return this.#namespace;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the bubbles read-only property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #bubbles = false;\r\n    /**\r\n     * Whether or not the event is bubbled.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get bubbles(){\r\n        return this.#bubbles;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the cancelable read-only property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #cancelable = false;\r\n    /**\r\n     * Whether or not the event is cancelable.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get cancelable(){\r\n        return this.#cancelable;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the defaultPrevented readonly property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    #defaultPrevented = false;\r\n    /**\r\n     * Whether or not the event is cancelable and preventDefault has been called.\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @default false\r\n     */\r\n    get defaultPrevented(){\r\n        return this.#defaultPrevented;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the target readonly property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #target = null;\r\n    /**\r\n     * The emitter that initially raised the event.\r\n     * @type {?Emitter}\r\n     * @default null\r\n     */\r\n    get target(){\r\n        return this.#target;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter that raised the event.\r\n     * @param {Emitter} emitterInstance\r\n     * @throws {TypeError} Throws a TypeError if the value is not an instance of Emitter.\r\n     */\r\n    set target(emitterInstance){\r\n        if (emitterInstance instanceof Emitter){\r\n            this.#target = emitterInstance;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The EmitterEvent.target must be an instance of Emitter.\");\r\n    }\r\n\r\n    /**\r\n     * The private field used by the currenTarget readonly property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #currenTarget = null;\r\n    /**\r\n     * The emitter currently raising the event.\r\n     * @type {?Emitter}\r\n     * @default null\r\n     */\r\n    get currenTarget(){\r\n        return this.#currenTarget;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter currently raising the event.\r\n     * @param {Emitter} emitterInstance\r\n     * @throws {TypeError} Throws a TypeError if the value is not an instance of Emitter.\r\n     */\r\n    set currenTarget(emitterInstance){\r\n        if (emitterInstance instanceof Emitter){\r\n            this.#currenTarget = emitterInstance;\r\n            return;\r\n        }\r\n        throw new TypeError(\"The EmitterEvent.currenTarget must be an instance of Emitter.\");\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Specifies the default action should not be taken. Calling this method on a non-cancelable event has no effect.\r\n     */\r\n    preventDefault() {\r\n        if (!this.cancelable) return;\r\n        this.#defaultPrevented = true;\r\n    }\r\n\r\n    /**\r\n     * Whether or not the default action should not be taken.\r\n     * @returns {boolean}\r\n     */\r\n    isDefaultPrevented() {\r\n        return this.defaultPrevented;\r\n    }\r\n\r\n    #propagationStopped = false;\r\n    stopPropagation(){\r\n        this.#propagationStopped = true;\r\n    }\r\n\r\n    isPropagationStopped(){\r\n        return this.#propagationStopped;\r\n    }\r\n\r\n    //endregion\r\n\r\n}\r\n\r\nexport default EmitterEvent;","import {isFunction, isPlainObject, isStringNotEmpty, isUndefined} from \"./is\";\r\nimport EmitterEvent from \"./EmitterEvent\";\r\nimport {defaults, objForEach} from \"./object\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * A function that can handle an event emitted by an Emitter object.\r\n * @callback EmitterListener\r\n * @param {EmitterEvent} [event]\r\n * @param {...*} [args]\r\n */\r\n/**\r\n * An object containing event type to listener mappings.\r\n * @typedef {object} EmitterMap\r\n * @example\r\n *  {\r\n *      \"some-event\": (event, ...args) => { },\r\n *      \"another-event\": (event, ...args) => { }\r\n *  }\r\n */\r\n/**\r\n * The result of the Emitter.parseType method.\r\n * @typedef {object} EmitterType\r\n * @property {?string} [type] - The type of the event.\r\n * @property {?string} [namespace] - The namespace for the event.\r\n */\r\n/**\r\n * A map of event type to namespaces.\r\n * @typedef {Map<string, EmitterNamespaces>} EmitterEvents\r\n */\r\n/**\r\n * A map of namespace to listeners.\r\n * @typedef {Map<?string, EmitterListeners>} EmitterNamespaces\r\n */\r\n/**\r\n * A map of listener to thisArgs\r\n * @typedef {Map<EmitterListener, Set<*>>} EmitterListeners\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Create a new Emitter instance.\r\n * @class Emitter\r\n * @param {EmitterEventOptions} [options] - The default options for events created by this instance.\r\n * @param {Emitter} [parentEmitter] - The parent emitter for this instance.\r\n */\r\nclass Emitter {\r\n\r\n    //region static\r\n\r\n    /**\r\n     * The separator used to parse eventType strings into there component type and namespace values.\r\n     * @type {string}\r\n     * @default \".\"\r\n     */\r\n    static EVENT_TYPE_NAMESPACE_SEPARATOR = \".\";\r\n\r\n    /**\r\n     * Parses the supplied event type string into its component type and namespace values.\r\n     * @param {string} type - The event type string to parse.\r\n     * @param {boolean} [required=false] - Whether to throw a TypeError if the parsed type is empty.\r\n     * @returns {EmitterType}\r\n     * @throws {TypeError} Throws a TypeError if the supplied `type` or return value is invalid.\r\n     */\r\n    static parseType(type, required){\r\n        if (!isStringNotEmpty(type)) {\r\n            throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        }\r\n        let namespace = null, parsedType = type;\r\n        const n_index = type.indexOf(this.EVENT_TYPE_NAMESPACE_SEPARATOR);\r\n        if (n_index !== -1){\r\n            namespace = type.slice(n_index + 1) || null;\r\n            parsedType = type.slice(0, n_index) || null;\r\n        }\r\n        if ((!namespace && !parsedType) || (!parsedType && required)){\r\n            throw new TypeError(`Unable to parse the event type: \"${type}\"`);\r\n        }\r\n        return { type: parsedType, namespace };\r\n    }\r\n\r\n    //endregion\r\n\r\n    //#region constructor\r\n\r\n    /**\r\n     * @constructs\r\n     * @param {EmitterEventOptions} [options] - The default options for events created by this instance.\r\n     * @param {Emitter} [parentEmitter] - The parent emitter for this instance.\r\n     */\r\n    constructor(options, parentEmitter) {\r\n        this.#emitterEventDefaults = {...this.#emitterEventDefaults, ...options};\r\n        this.#parentEmitter = parentEmitter instanceof Emitter ? parentEmitter : null;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the __events__ read-only property.\r\n     * @type {EmitterEvents}\r\n     * @private\r\n     */\r\n    #events = new Map();\r\n\r\n    /**\r\n     * A map of event types to handler arrays for this instance.\r\n     * @type {EmitterEvents}\r\n     * @readonly\r\n     */\r\n    get __events__(){\r\n        return this.#events;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the __emitterEventDefaults__ read-only property.\r\n     * @type {EmitterEventOptions}\r\n     * @private\r\n     */\r\n    #emitterEventDefaults = {\r\n        bubbles: false,\r\n        cancelable: false\r\n    };\r\n\r\n    /**\r\n     * The default options for events created by this instance. Should be set through the constructor call.\r\n     * @type {EmitterEventOptions}\r\n     * @readonly\r\n     */\r\n    get __emitterEventDefaults__(){\r\n        return this.#emitterEventDefaults;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the __parentEmitter__ read-only property.\r\n     * @type {?Emitter}\r\n     * @private\r\n     */\r\n    #parentEmitter = null;\r\n\r\n    /**\r\n     * The parent emitter for this instance.\r\n     * @type {?Emitter}\r\n     * @readonly\r\n     */\r\n    get __parentEmitter__(){\r\n        return this.#parentEmitter;\r\n    }\r\n\r\n    //endregion\r\n\r\n    /**\r\n     * Sets up a function that will be called whenever the specified event is delivered to the target.\r\n     * @param {string} type - A case-sensitive string representing the event type to listen for.\r\n     * @param {EmitterListener} listener - The callback that receives a notification when an event of the specified type occurs.\r\n     * @param {*} [thisArg] - The value of this within the listener.\r\n     */\r\n    #addListener(type, listener, thisArg) {\r\n        if (!isStringNotEmpty(type)) throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        if (!isFunction(listener)) throw new TypeError(\"The 'listener' argument must be a function.\");\r\n        thisArg = thisArg ?? this;\r\n        type.split(\" \").forEach((eventType) => {\r\n            if (!isStringNotEmpty(eventType)) return;\r\n            const parsed = Emitter.parseType(eventType, true);\r\n            let namespaces = this.#events.get(parsed.type);\r\n            if (!namespaces) this.#events.set(parsed.type, (namespaces = new Map()));\r\n            let listeners = namespaces.get(parsed.namespace);\r\n            if (!listeners) namespaces.set(parsed.namespace, (listeners = new Map()));\r\n            let thisArgs = listeners.get(listener);\r\n            if (!thisArgs) listeners.set(listener, (thisArgs = new Set()));\r\n            thisArgs.add(thisArg);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes an event listener previously registered with Emitter.addEmitterListener\r\n     * @param {string} type - A string which specifies the type of event for which to remove an event listener.\r\n     * @param {EmitterListener} [listener] - The listener of the event handler to remove. If not supplied all listeners for the event type are removed.\r\n     * @param {*} [thisArg] - The thisArg value of the event handler to remove. If not supplied all listeners that match the listener and event type are removed.\r\n     */\r\n    #removeListener(type, listener, thisArg) {\r\n        if (!isStringNotEmpty(type)) throw new TypeError(\"The 'type' argument must be a non-empty string.\");\r\n        thisArg = thisArg ?? this;\r\n        type.split(\" \").forEach((eventType) => {\r\n            if (!isStringNotEmpty(eventType)) return;\r\n            const parsed = Emitter.parseType(eventType);\r\n            const types = [];\r\n            if (isStringNotEmpty(parsed.type)) {\r\n                types.push(parsed.type);\r\n            } else if (isStringNotEmpty(parsed.namespace)) {\r\n                for (const [type, namespaces] of this.#events){\r\n                    if (!namespaces.has(parsed.namespace)) continue;\r\n                    types.push(type);\r\n                }\r\n            }\r\n            types.forEach((type) => {\r\n                // a type was provided but doesn't exist so do nothing\r\n                if (!this.#events.has(type)) return;\r\n                const namespaces = this.#events.get(type);\r\n                // a namespace was provided but doesn't exist so do nothing\r\n                if (!namespaces.has(parsed.namespace)) return;\r\n                if (isFunction(listener)){\r\n                    const listeners = namespaces.get(parsed.namespace);\r\n                    // a listener was provided but doesn't exist so do nothing\r\n                    if (!listeners.has(listener)) return;\r\n                    if (!isUndefined(thisArg)){\r\n                        const thisArgs = listeners.get(listener);\r\n                        // a thisArg was provided but doesn't exist so do nothing\r\n                        if (!thisArgs.has(thisArg)) return;\r\n                        // remove just the specified thisArg for the type, namespace & listener\r\n                        thisArgs.delete(thisArg);\r\n                        // if the last thisArg was removed then remove the listener\r\n                        if (thisArgs.size === 0) listeners.delete(listener);\r\n                    } else {\r\n                        // no thisArg was provided so just remove the entire listener for the type & namespace\r\n                        listeners.delete(listener);\r\n                    }\r\n                    // if the last listener was removed then remove the namespace\r\n                    if (listeners.size === 0) namespaces.delete(parsed.namespace);\r\n                } else {\r\n                    // no listener was provided so remove all listeners for the type & namespace\r\n                    namespaces.delete(parsed.namespace);\r\n                }\r\n                // if the last namespace was removed then remove the type\r\n                if (namespaces.size === 0) this.#events.delete(type);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The callback executed for each event type and listener parsed from the arguments.\r\n     * @callback forListener~callback\r\n     * @param {string} type\r\n     * @param {EmitterListener} listener\r\n     * @param {*} thisArg\r\n     * @this {Emitter}\r\n     */\r\n    /**\r\n     * Parse and iterate over the arguments supplied to the .on() and .off() methods.\r\n     * @param {IArguments} args\r\n     * @param {forListener~callback} callback\r\n     * @param {*} [thisArg] - The initial value of the thisArg.\r\n     * @private\r\n     */\r\n    #forListener(args, callback, thisArg){\r\n        if (args.length >= 2 && isStringNotEmpty(args[0]) && isFunction(args[1])) {\r\n            // dealing with (type, listener) OR (type, listener, thisArg)\r\n            if (args.length === 3) thisArg = args[2];\r\n            callback.call(this, args[0], args[1], thisArg);\r\n        } else if (args.length >= 1 && isPlainObject(args[0])) {\r\n            // dealing with (EmitterMap) OR (EmitterMap, thisArg)\r\n            if (args.length === 2) thisArg = args[1];\r\n            objForEach(args[0], (type, listener) => {\r\n                callback.call(this, type, listener, thisArg);\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add event listeners to this instance.\r\n     * @param {string|EmitterMap} typeOrTypeMap - A event type string or an object map of event type keys to listener values.\r\n     * @param {EmitterListener|*} [typeListenerOrTypeMapThisArg] - If the first parameter is a string, this should be a listener function. If the first parameter is an object, this is the thisArg to bind all listeners with.\r\n     * @param {*} [typeThisArg] - If the first parameter is a string and the second a listener, this is the thisArg to bind the listener with.\r\n     * @returns {this}\r\n     */\r\n    on(typeOrTypeMap, typeListenerOrTypeMapThisArg, typeThisArg){\r\n        return this.#forListener(arguments, this.#addListener);\r\n    }\r\n\r\n    /**\r\n     * Remove event listeners from this instance.\r\n     * @param {string|EmitterMap} typeOrTypeMap - A event type string or an object map of event type keys to listener values.\r\n     * @param {EmitterListener|*} [typeListenerOrTypeMapThisArg] - If the first parameter is a string, this should be a listener function. If the first parameter is an object, this is the thisArg to bind all listeners with.\r\n     * @param {*} [typeThisArg] - If the first parameter is a string and the second a listener, this is the thisArg to bind the listener with.\r\n     * @returns {this}\r\n     */\r\n    off(typeOrTypeMap, typeListenerOrTypeMapThisArg, typeThisArg){\r\n        return this.#forListener(arguments, this.#removeListener);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {...*} [args]\r\n     * @returns {boolean} Returns true if defaultPrevented was not called.\r\n     */\r\n    emit(event, ...args) {\r\n        if (event instanceof EmitterEvent) {\r\n            if (event.target === null) event.target = this;\r\n            if (event.currenTarget !== this) event.currenTarget = this;\r\n            const emit = (namespaces) => {\r\n                if (!namespaces.has(event.namespace)) return;\r\n                const listeners = namespaces.get(event.namespace);\r\n                for (const [listener, thisArgs] of listeners) {\r\n                    for (const thisArg of thisArgs) {\r\n                        listener.call(thisArg, event, ...args);\r\n                    }\r\n                }\r\n            };\r\n            if (this.#events.has(event.type)) {\r\n                emit(this.#events.get(event.type));\r\n            }\r\n            if (this.#events.has(\"*\")) {\r\n                emit(this.#events.get(\"*\"));\r\n            }\r\n            if (event.bubbles && !event.isPropagationStopped() && this.#parentEmitter instanceof Emitter) {\r\n                return this.#parentEmitter.emit(event, ...args);\r\n            }\r\n            return !event.isDefaultPrevented();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} event\r\n     * @param {Array} [args]\r\n     * @param {EmitterEventOptions} [options]\r\n     * @returns {boolean}\r\n     */\r\n    trigger(event, args, options) {\r\n        if (!isStringNotEmpty(event)) return false;\r\n        args = Array.isArray(args) ? args : [];\r\n        options = defaults(options, this.#emitterEventDefaults);\r\n        return event.split(\" \")\r\n            .map((type) => this.emit(new EmitterEvent(type, options, this), ...args))\r\n            .every((success) => success);\r\n    }\r\n}\r\n\r\nexport default Emitter;","import {isStringNotEmpty} from \"./is\";\r\n\r\n/**\r\n * If the value is a string it is returned, if it's a string array the values are joined using a comma, otherwise null is returned.\r\n * @param {*} value\r\n * @returns {?string}\r\n */\r\nfunction makeSelector(value){\r\n    if (isStringNotEmpty(value)) {\r\n        return value;\r\n    }\r\n    if (Array.isArray(value) && value.length) {\r\n        const result = value.filter((val) => isStringNotEmpty(val)).join(\",\");\r\n        return isStringNotEmpty(result) ? result : null;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport default makeSelector;","import {isFunction, isPlainObject, isStringNotEmpty} from \"../../utils/is\";\r\nimport mergeArray from \"../../utils/mergeArray\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback PropertyParser~ctor\r\n * @param {TypeParser} parent\r\n * @param {PropertyParser~Configuration} configuration\r\n * @returns {PropertyParser}\r\n */\r\n/**\r\n * @typedef {object} PropertyParserDefinition\r\n * @property {PropertyParser~Configuration} configuration\r\n * @property {PropertyParser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default property parser is registered using the new name. If an array, the first element is the name, the second is the custom property parser constructor.\r\n * @typedef {PropertyParser~Configuration|[PropertyParser~Configuration,PropertyParser~ctor]} propertyParserDefinition\r\n */\r\n/**\r\n * A method used to test the parsed value to check if it is valid.\r\n * @callback PropertyParser~test\r\n * @param {*} value\r\n * @param {PropertyParser} [propertyParser]\r\n * @returns {boolean}\r\n */\r\n/**\r\n * A method used to convert the parsed value to a specific type.\r\n * @callback PropertyParser~convert\r\n * @param {*} value\r\n * @param {PropertyParser} [propertyParser]\r\n * @returns {*}\r\n */\r\n/**\r\n * The configuration for parsing a property from an object.\r\n * @typedef {object} PropertyParser~Configuration\r\n * @property {string} name - The name of the property as it appears in the resulting properties object.\r\n * @property {boolean} [required=false] - Whether or not this property is required. If set to true and the parsed value is null, undefined or the same as the defaultValue the item will fail to parse.\r\n * @property {boolean} [tracked=false] - Whether or not changes to this property are tracked. By default all required properties are tracked and will ignore this value.\r\n * @property {*} [defaultValue=null] - The default value returned for this property if none is parsed.\r\n * @property {PropertyParser~test} [test] - A method used to test the parsed value to check if it is valid. If not supplied the value is considered valid if: value != null && value !== defaultValue\r\n * @property {PropertyParser~convert} [convert] - A method used to convert the parsed value to a specific type.\r\n * @property {string} [queryParent=\"^\"]\r\n * @property {string} [queryPath=\"/\"]\r\n * @property {string} [queryType=\":\"]\r\n * @property {string[]} [obj=[]] - An array of queries used to parse a plain object reference for the property value. The properties are iterated in index order and the first match is returned.\r\n * @property {string[]} [elem=[]] - An array of queries used to parse an HTMLElement reference for the property value. The queries are iterated in index order and the first match is returned.\r\n */\r\n\r\n\r\n//endregion\r\n\r\nexport default class PropertyParser {\r\n\r\n    //#region static\r\n\r\n    /**\r\n     * The default convert method used by all properties. This does nothing but pass through the supplied value.\r\n     * @param {*} value - The parsed value.\r\n     * @param {PropertyParser} property - The property object itself.\r\n     * @returns {*}\r\n     */\r\n    static DEFAULT_CONVERT( value, property ){\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * The default test method used by all properties to determine if the parsed value is valid.\r\n     * @param {*} value - The parsed value.\r\n     * @param {PropertyParser} property - The property object itself.\r\n     * @returns {boolean}\r\n     */\r\n    static DEFAULT_TEST( value, property ){\r\n        return value != null && value !== property.defaultValue;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {propertyParserDefinition} configuration\r\n     * @returns {?PropertyParserDefinition}\r\n     */\r\n    static DEFINITION( configuration ){\r\n        if ( isPlainObject( configuration ) ){\r\n            return { configuration: /** @type PropertyParser~Configuration */ configuration, ctor: /** @type PropertyParser~ctor */ PropertyParser };\r\n        }\r\n        if ( Array.isArray( configuration ) && configuration.length === 2 && isPlainObject( configuration[0] ) && isFunction( configuration[1] ) ){\r\n            return { configuration: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Merges all property definitions from the source into the target, properties are compared by name.\r\n     * @param {propertyParserDefinition[]} target - The target array to push definitions into.\r\n     * @param {propertyParserDefinition[]} source - The source array to pull definitions from.\r\n     * @returns {propertyParserDefinition[]}\r\n     */\r\n    static MERGE_DEFINITIONS( target, source ){\r\n        return mergeArray( target, source, ( targetDefinition, sourceDefinition ) => {\r\n            const targetDef = PropertyParser.DEFINITION( targetDefinition ),\r\n                sourceDef = PropertyParser.DEFINITION( sourceDefinition );\r\n            if ( !targetDef || !sourceDef ) return false;\r\n            return targetDef.configuration.name === sourceDef.configuration.name;\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {TypeParser} typeParser\r\n     * @param {propertyParserDefinition} definition\r\n     * @returns {?PropertyParser}\r\n     */\r\n    static create( typeParser, definition ){\r\n        const def = PropertyParser.DEFINITION( definition );\r\n        return def ? new def.ctor( typeParser, def.configuration ) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {TypeParser} typeParser\r\n     * @param {propertyParserDefinition[]} propertyParserDefinitions\r\n     * @returns {PropertyParser[]}\r\n     */\r\n    static createAll( typeParser, propertyParserDefinitions ){\r\n        return propertyParserDefinitions.reduce( ( result, definition ) => {\r\n            const propertyParser = PropertyParser.create( typeParser, definition );\r\n            if ( propertyParser ) result.push( propertyParser );\r\n            return result;\r\n        },/** @type {PropertyParser[]} */ [] );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} ref\r\n     * @param {PropertyParser[]} properties\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {?object}\r\n     */\r\n    static getValues( ref, properties, nocache ){\r\n        const result = {};\r\n        for ( const property of properties ){\r\n            const value = property.getValue( ref, nocache );\r\n            if ( property.required && !property.test( value ) ){\r\n                // if there is a required property that is not supplied then stop parsing and exit early\r\n                return null;\r\n            } else {\r\n                result[ property.name ] = value;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of a PropertyParser.\r\n     * @param {TypeParser} typeParser - The parent type parser for this instance.\r\n     * @param {PropertyParser~Configuration} configuration - The configuration for this instance.\r\n     */\r\n    constructor( typeParser, configuration ) {\r\n        this.#typeParser = typeParser;\r\n        this.#name = configuration.name;\r\n        this.required = configuration.required ?? false;\r\n        this.defaultValue = configuration.defaultValue ?? null;\r\n        this.#convert = configuration.convert ?? PropertyParser.DEFAULT_CONVERT;\r\n        this.#test = configuration.test ?? PropertyParser.DEFAULT_TEST;\r\n        this.queryParent = configuration.queryParent ?? \"^\";\r\n        this.queryPath = configuration.queryPath ?? \"/\";\r\n        this.queryType = configuration.queryType ?? \":\";\r\n        if ( Array.isArray( configuration.obj ) ){\r\n            this.obj = configuration.obj.map( ( query ) => this.objectQuery( query ) ).filter( ( query ) => query != null);\r\n        }\r\n        if ( Array.isArray( configuration.elem ) ){\r\n            this.elem = configuration.elem.map( ( query ) => this.elementQuery( query ) ).filter( ( query ) => query != null);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region properties\r\n\r\n    /**\r\n     * The private field used by the 'typeParser' read-only property.\r\n     * @type {TypeParser}\r\n     * @private\r\n     */\r\n    #typeParser;\r\n    /**\r\n     * Get the parent type parser.\r\n     * @type {TypeParser}\r\n     * @readonly\r\n     */\r\n    get typeParser(){\r\n        return this.#typeParser;\r\n    }\r\n\r\n    get parser(){\r\n        return this.typeParser.parser;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the property was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Whether this property is required.\r\n     * @type {boolean}\r\n     * @default false\r\n     */\r\n    required;\r\n    /**\r\n     * The default value returned if none is parsed.\r\n     * @type {*}\r\n     * @default null\r\n     */\r\n    defaultValue;\r\n    /**\r\n     * The delimiter used by element queries to target a parent element.\r\n     * @type {string}\r\n     * @default \"^\"\r\n     */\r\n    queryParent;\r\n    /**\r\n     * The delimiter used by queries to target either a child element or object property.\r\n     * @type {string}\r\n     * @default \"/\"\r\n     */\r\n    queryPath;\r\n    /**\r\n     * The delimiter used by element queries to specify where the value should be pulled from.\r\n     * @type {string}\r\n     * @default \":\"\r\n     */\r\n    queryType;\r\n    /**\r\n     * An array of compiled queries used to interrogate plain objects.\r\n     * @type {ObjectQuery[]}\r\n     */\r\n    obj = [];\r\n    /**\r\n     * An array of compiled queries used to interrogate elements.\r\n     * @type {ElementQuery[]}\r\n     */\r\n    elem = [];\r\n    /**\r\n     * The method used to convert the parsed value to another type.\r\n     * @type {PropertyParser~convert}\r\n     * @default Property.DEFAULT_CONVERT\r\n     */\r\n    #convert;\r\n    /**\r\n     * The method used to test if the parsed value is valid.\r\n     * @type {PropertyParser~test}\r\n     * @default Property.DEFAULT_CONVERT\r\n     */\r\n    #test;\r\n    /**\r\n     *\r\n     * @type {Map<string, *>}\r\n     */\r\n    #cache = new Map();\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * @typedef {object} PropertyQuery\r\n     * @property {string} raw\r\n     * @property {string} name\r\n     * @property {function(*):*} getValue\r\n     */\r\n\r\n    /**\r\n     *\r\n     * @param {string} query\r\n     * @returns {?ObjectQuery}\r\n     */\r\n    objectQuery( query ){\r\n        /**\r\n         * @typedef {PropertyQuery} ObjectQuery\r\n         * @property {string[]} path\r\n         */\r\n        if ( isStringNotEmpty( query ) ){\r\n            let name = query, path = [];\r\n            if ( name.indexOf( this.queryPath ) !== -1 ){\r\n                const parts = name.split( this.queryPath );\r\n                name = parts.pop();\r\n                path.push( parts );\r\n            }\r\n            const target = ( ref ) => {\r\n                let result = ref;\r\n                for ( const part of path ){\r\n                    result = result[ part ];\r\n                    if ( !result ) break;\r\n                }\r\n                return result ?? null;\r\n            };\r\n            return {\r\n                raw: query,\r\n                name,\r\n                path,\r\n                getValue: ( ref ) => {\r\n                    const targetRef = target( ref );\r\n                    if ( targetRef ){\r\n                        return this.convert( targetRef[ name ] ) ?? this.defaultValue;\r\n                    }\r\n                    return this.defaultValue;\r\n                }\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *\r\n     * @param {string} query\r\n     * @returns {?ElementQuery}\r\n     */\r\n    elementQuery( query ){\r\n        /**\r\n         * @typedef {PropertyQuery} ElementQuery\r\n         * @property {number} parents\r\n         * @property {?string} selector\r\n         */\r\n        if ( isStringNotEmpty( query ) ){\r\n            let name = query, parents = 0, selector = null, type = \"prop\";\r\n            while ( name[0] === this.queryParent ){\r\n                parents++;\r\n                name = name.slice(1);\r\n            }\r\n            if ( name.indexOf( this.queryPath ) !== -1 ){\r\n                const parts = name.split( this.queryPath );\r\n                selector = parts[0];\r\n                name = parts[1];\r\n            }\r\n            if ( name.indexOf( this.queryType ) !== -1 ){\r\n                const parts = name.split( this.queryType );\r\n                type = parts[0];\r\n                name = parts[1];\r\n            }\r\n            const target = ( ref ) => {\r\n                let result = ref;\r\n                for ( let i = 0; i < parents; i++ ){\r\n                    result = result.parentElement;\r\n                    if ( !result ) break;\r\n                }\r\n                return result && selector ? result.querySelector( selector ) : result;\r\n            };\r\n            let getValue;\r\n            switch ( type ){\r\n                case \"prop\":\r\n                    getValue = ( ref ) => { return this.convert( ref[ name ] ) ?? this.defaultValue; };\r\n                    break;\r\n                case \"data\":\r\n                    getValue = ( ref ) => { return this.convert( ref.dataset[ name ] ) ?? this.defaultValue; };\r\n                    break;\r\n                case \"attr\":\r\n                    getValue = ( ref ) => { return ref.hasAttribute( name ) ? this.convert( ref.getAttribute( name ) ) : this.defaultValue; };\r\n                    break;\r\n                default:\r\n                    getValue = () => this.defaultValue;\r\n                    break;\r\n            }\r\n            return {\r\n                raw: query,\r\n                name,\r\n                type,\r\n                parents,\r\n                selector,\r\n                getValue: ( ref ) => {\r\n                    const targetRef = target( ref );\r\n                    if ( targetRef ){\r\n                        return getValue( targetRef );\r\n                    }\r\n                    return this.defaultValue;\r\n                }\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param ref\r\n     * @param nocache\r\n     * @returns {*}\r\n     */\r\n    getValue( ref, nocache ){\r\n        if ( !nocache && this.#cache.has( ref ) ){\r\n            return this.#cache.get( ref );\r\n        }\r\n        let result = this.defaultValue, query;\r\n        if ( ref instanceof HTMLElement ){\r\n            for ( query of this.elem ){\r\n                const value = query.getValue( ref );\r\n                if ( this.test( value ) ){\r\n                    result = value;\r\n                    break;\r\n                }\r\n            }\r\n        } else if ( isPlainObject( ref ) ){\r\n            for ( query of this.obj ){\r\n                const value = query.getValue( ref );\r\n                if ( this.test( value ) ){\r\n                    result = value;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const prop = { name: this.name, type: this.typeParser.name, value: result, query, ref };\r\n        this.parser.trigger( 'get-property', [ prop ] );\r\n        this.#cache.set( ref, prop.value );\r\n        return prop.value;\r\n    }\r\n\r\n    convert(value){\r\n        return this.#convert( value, this );\r\n    }\r\n\r\n    test(value){\r\n        return this.#test( value, this );\r\n    }\r\n}","import {isFunction} from \"./is\";\r\n\r\n/**\r\n * @template T\r\n * @param {Array<T>} target\r\n * @param {Array<T>} source\r\n * @param {function(T, T):boolean} [equalityComparer]\r\n * @returns {Array<T>}\r\n */\r\nfunction mergeArray(target, source, equalityComparer){\r\n    if (isFunction(equalityComparer)){\r\n        return [...target, ...source.filter((sourceValue) => !target.some((targetValue) => equalityComparer(targetValue, sourceValue)))];\r\n    }\r\n    return [...target, ...source.filter((targetValue) => !target.includes(targetValue))];\r\n}\r\n\r\nexport default mergeArray;","/**\r\n * A simple class containing the results of a parsed item.\r\n */\r\nexport default class Item {\r\n    /**\r\n     * A reference to the parent container this item belongs to.\r\n     */\r\n    parent;\r\n\r\n    /**\r\n     * A reference to the type parser that produced this item.\r\n     * @type {TypeParser}\r\n     */\r\n    type;\r\n\r\n    /**\r\n     * The reference object parsed.\r\n     * @type {*}\r\n     */\r\n    ref;\r\n\r\n    /**\r\n     * An object containing all required properties for the item.\r\n     * @type {object}\r\n     */\r\n    requiredProperties;\r\n\r\n    /**\r\n     * @type {?EventTarget}\r\n     * @private\r\n     */\r\n    #triggerTarget = null;\r\n\r\n    /**\r\n     * Create a new instance of the ParserItem class.\r\n     * @param {Container} parent - A reference to the parent container this item belongs to.\r\n     * @param {TypeParser} type - A reference to the type parser that produced this item.\r\n     * @param {*} ref - The reference object parsed.\r\n     * @param {?EventTarget} [triggerTarget] - The EventTarget instance that triggers this item.\r\n     */\r\n    constructor(parent, type, ref, triggerTarget) {\r\n        this.parent = parent;\r\n        this.type = type;\r\n        this.ref = ref;\r\n        if ( triggerTarget instanceof EventTarget ){\r\n            this.#triggerTarget = triggerTarget;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The EventTarget instance that triggers this item.\r\n     * @returns {?EventTarget}\r\n     */\r\n    get triggerTarget(){\r\n        return this.#triggerTarget;\r\n    }\r\n\r\n    /**\r\n     * @param {EventTarget} value - The EventTarget instance to use as the trigger.\r\n     */\r\n    set triggerTarget( value ){\r\n        if ( value instanceof EventTarget ){\r\n            this.#triggerTarget = value;\r\n            return;\r\n        }\r\n        throw new TypeError( \"The Item.trigger property must be an instance of EventTarget!\" );\r\n    }\r\n\r\n    /**\r\n     * Get all properties for this item.\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {object}\r\n     */\r\n    getProperties( nocache ){\r\n        const properties = this.type.getProperties( this.ref, nocache );\r\n        return { ...properties, type: this.type.name };\r\n    }\r\n\r\n    #properties;\r\n\r\n    get properties(){\r\n        if ( !this.#properties ){\r\n            this.#properties = this.getProperties();\r\n        }\r\n        return this.#properties;\r\n    }\r\n}","import {isFunction, isPlainObject, isStringNotEmpty} from \"../../utils/is\";\r\nimport {defaults} from \"../../utils/object\";\r\nimport makeSelector from \"../../utils/makeSelector\";\r\nimport PropertyParser from \"./PropertyParser\";\r\nimport Item from \"./Item\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback TypeParser~ctor\r\n * @param {Parser} parser\r\n * @param {string} name\r\n * @returns TypeParser\r\n */\r\n/**\r\n * @typedef {object} TypeParserDefinition\r\n * @property {string} name\r\n * @property {TypeParser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default type parser is registered using the new name. If an array, the first element is the name, the second is the custom type parser constructor.\r\n * @typedef {string|[string,TypeParser~ctor]} typeParserDefinition\r\n */\r\n/**\r\n * The configuration for parsing an item from an object.\r\n * @typedef {object} TypeParser~Configuration\r\n * @property {number} [priority=0]\r\n * @property {string[]} [include]\r\n * @property {string[]} [exclude]\r\n * @property {propertyParserDefinition[]} [properties]\r\n */\r\n\r\n//endregion\r\n\r\n/**\r\n * Parses item data from various sources depending on configuration.\r\n */\r\nexport default class TypeParser {\r\n\r\n    //region static\r\n\r\n    /**\r\n     *\r\n     * @param {typeParserDefinition} configuration\r\n     * @returns {?TypeParserDefinition}\r\n     */\r\n    static DEFINITION(configuration){\r\n        if (isStringNotEmpty(configuration)){\r\n            return { name: /** @type string */ configuration, ctor: /** @type TypeParser~ctor */ TypeParser };\r\n        }\r\n        if (Array.isArray(configuration) && configuration.length === 2 && isStringNotEmpty(configuration[0]) && isFunction(configuration[1])){\r\n            return { name: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Parser} parser\r\n     * @param {typeParserDefinition} definition\r\n     * @returns {?TypeParser}\r\n     */\r\n    static create(parser, definition){\r\n        const def = TypeParser.DEFINITION(definition);\r\n        return def ? new def.ctor(parser, def.name) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Parser} parser\r\n     * @param {typeParserDefinition[]} typeParserDefinitions\r\n     * @returns {TypeParser[]}\r\n     */\r\n    static createAll(parser, typeParserDefinitions){\r\n        return typeParserDefinitions.reduce((result, config) => {\r\n            const typeParser = TypeParser.create(parser, config);\r\n            if (typeParser) result.push(typeParser);\r\n            return result;\r\n        },/** @type {TypeParser[]} */ []).sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Parses item data from various sources depending on configuration.\r\n     * @param {Parser} parser - The parent parser for this instance.\r\n     * @param {string} name - The type of item parsed by this instance.\r\n     */\r\n    constructor(parser, name) {\r\n        this.#parser = parser;\r\n        this.#name = name;\r\n        defaults(this.config, this.defaults);\r\n        this.#includeSelector = makeSelector(this.config.include);\r\n        this.#excludeSelector = makeSelector(this.config.exclude);\r\n        this.#properties = PropertyParser.createAll(this, PropertyParser.MERGE_DEFINITIONS(this.config.properties, this.parser.config.defaultProperties));\r\n        this.#requiredProperties = this.properties.filter((property) => property.required);\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'parent' read-only property.\r\n     * @type {Parser}\r\n     * @private\r\n     */\r\n    #parser;\r\n    /**\r\n     * Get the parent parser.\r\n     * @type {Parser}\r\n     * @readonly\r\n     */\r\n    get parser(){\r\n        return this.#parser;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the type parser was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Get the default type parser configuration.\r\n     * @type {TypeParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get defaults(){\r\n        return {\r\n            priority: 0,\r\n            include: [],\r\n            exclude: [],\r\n            properties: [],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the parser configuration.\r\n     * @type {TypeParser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if (isPlainObject(this.parser.config[this.name])){\r\n            return this.parser.config[this.name];\r\n        }\r\n        return this.parser.config[this.name] = {};\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'priority' read-only property.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    #priority;\r\n    /**\r\n     * Get the priority.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    get priority(){\r\n        return this.#priority;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'includeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #includeSelector;\r\n    /**\r\n     * Get the result of combining all configured include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get includeSelector(){\r\n        return this.#includeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'excludeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #excludeSelector;\r\n    /**\r\n     * Get the result of combining all configured exclude selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get excludeSelector(){\r\n        return this.#excludeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'properties' read-only property.\r\n     * @type {PropertyParser[]}\r\n     * @private\r\n     */\r\n    #properties;\r\n    /**\r\n     * Get all configured property parsers.\r\n     * @type {PropertyParser[]}\r\n     * @readonly\r\n     */\r\n    get properties(){\r\n        return this.#properties;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'requiredProperties' read-only property.\r\n     * @type {PropertyParser[]}\r\n     * @private\r\n     */\r\n    #requiredProperties;\r\n    /**\r\n     * Get all configured required property parsers.\r\n     * @type {PropertyParser[]}\r\n     * @readonly\r\n     */\r\n    get requiredProperties(){\r\n        return this.#requiredProperties;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Item>}\r\n     */\r\n    #cache = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #requiredPropertyCache = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #propertyCache = new Map();\r\n\r\n    //endregion\r\n\r\n    /**\r\n     * Checks if the supplied reference is included by this instance.\r\n     * NOTE: This DOES NOT check for exclusions! Use the canParse method if you want to check if a reference is both included AND NOT excluded.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    includes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.includeSelector !== null && ref.matches(this.includeSelector);\r\n        }\r\n        if (isPlainObject(ref)){\r\n            return ref.type === this.name;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference is excluded by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    excludes(ref){\r\n        if (ref instanceof HTMLElement){\r\n            return this.excludeSelector !== null && ref.matches(this.excludeSelector);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference can be parsed by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    canParse(ref) {\r\n        return this.includes(ref) && !this.excludes(ref);\r\n    }\r\n\r\n    create(parent, ref, trigger){\r\n        if (ref instanceof HTMLElement || isPlainObject(ref)){\r\n            return new Item(parent, this, ref, trigger);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new ParserItem.\r\n     * @param {Container} parent - The parent container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - Whether to ignore any cached values when parsing the item.\r\n     * @returns {Item|null} Returns null if parsing fails.\r\n     */\r\n    parse( parent, ref, nocache ){\r\n        let item;\r\n        if (this.#cache.has(ref)){\r\n            item = this.#cache.get(ref);\r\n        } else {\r\n            item = this.create(parent, ref, this.getTrigger(ref));\r\n        }\r\n        if (item instanceof Item){\r\n            const properties = this.getRequiredProperties(ref, nocache);\r\n            if (!properties){\r\n                this.#cache.delete(ref);\r\n                return null;\r\n            }\r\n            item.requiredProperties = properties;\r\n            this.#cache.set(ref, item);\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n     * Gets the trigger element for the reference object. Trigger elements are used to open the modal.\r\n     * @param {*} ref - The reference object to get the trigger from.\r\n     * @returns {?HTMLElement} Returns null if the item has no trigger element.\r\n     */\r\n    getTrigger(ref){\r\n        return ref instanceof HTMLElement ? ref : null;\r\n    }\r\n\r\n    getRequiredProperties(ref, nocache){\r\n        if (!nocache && this.#requiredPropertyCache.has(ref)){\r\n            return this.#requiredPropertyCache.get(ref);\r\n        }\r\n        const properties = PropertyParser.getValues(ref, this.requiredProperties, nocache);\r\n        this.#requiredPropertyCache.set(ref, properties);\r\n        return properties;\r\n    }\r\n\r\n    getProperties(ref, nocache){\r\n        if (!nocache && this.#propertyCache.has(ref)){\r\n            return this.#propertyCache.get(ref);\r\n        }\r\n        const properties = PropertyParser.getValues(ref, this.properties, nocache);\r\n        this.#propertyCache.set(ref, properties);\r\n        return properties;\r\n    }\r\n}","import { extend } from \"../../utils/object\";\r\nimport { isNumber } from \"../../utils/is\";\r\n\r\n/**\r\n * A simple class containing the results of parsing a reference object.\r\n */\r\nexport default class Container {\r\n\r\n    /**\r\n     * A reference to the parser that produced this result.\r\n     * @type {Parser}\r\n     */\r\n    parser;\r\n\r\n    /**\r\n     * The reference object parsed.\r\n     * @type {*}\r\n     */\r\n    ref;\r\n\r\n    /**\r\n     * An object containing any parsed options.\r\n     * @type {object}\r\n     */\r\n    options;\r\n\r\n    /**\r\n     * @type {?EventTarget}\r\n     * @private\r\n     */\r\n    #triggerTarget = null;\r\n\r\n    /**\r\n     * An array of all parsed items.\r\n     * @type {Item[]}\r\n     */\r\n    items = [];\r\n\r\n    /**\r\n     * Create a new instance of the Container class.\r\n     * @param {Parser} parser - A reference to the parser that produced this container.\r\n     * @param {*} ref - The reference object parsed.\r\n     * @param {object} [options] - An object containing any parsed options.\r\n     * @param {?EventTarget} [triggerTarget] - The EventTarget instance that triggers the modal.\r\n     */\r\n    constructor( parser, ref, options, triggerTarget ) {\r\n        this.parser = parser;\r\n        this.ref = ref;\r\n        this.options = extend( {}, options );\r\n        if ( triggerTarget instanceof EventTarget ){\r\n            this.#triggerTarget = triggerTarget;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The EventTarget instance that triggers the modal.\r\n     * @returns {?EventTarget}\r\n     */\r\n    get triggerTarget(){\r\n        return this.#triggerTarget;\r\n    }\r\n\r\n    /**\r\n     * @param {EventTarget} value - The EventTarget instance to use as the trigger.\r\n     */\r\n    set triggerTarget( value ){\r\n        if ( value instanceof EventTarget ){\r\n            this.#triggerTarget = value;\r\n            return;\r\n        }\r\n        throw new TypeError( \"The Container.triggerTarget property must be an instance of EventTarget.\" );\r\n    }\r\n\r\n    get firstIndex(){\r\n        return this.items.length ? 0 : -1;\r\n    }\r\n\r\n    get lastIndex(){\r\n        return this.items.length ? this.items.length - 1 : -1;\r\n    }\r\n\r\n    withinRange( index ){\r\n        return isNumber( index ) && index >= this.firstIndex && index <= this.lastIndex;\r\n    }\r\n\r\n    getByIndex( index ){\r\n        return this.withinRange( index ) ? this.items[ index ] : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {?Item}\r\n     */\r\n    getFirst(){\r\n        return this.firstIndex !== -1 ? this.items[ this.firstIndex ] : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {?Item}\r\n     */\r\n    getLast(){\r\n        return this.lastIndex !== -1 ? this.items[ this.lastIndex ] : null;\r\n    }\r\n\r\n    getNext( current, allowLoop ){\r\n        const index = this.items.indexOf( current );\r\n        if ( index !== -1 ){\r\n            let nextIndex = index + 1;\r\n            const withinRange = this.withinRange( nextIndex );\r\n            if ( withinRange ){\r\n                return this.items[ nextIndex ];\r\n            }\r\n            if ( !withinRange && allowLoop ){\r\n                return this.getFirst();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getPrevious( current, allowLoop ){\r\n        const index = this.items.indexOf( current );\r\n        if ( index !== -1 ){\r\n            let previousIndex = index - 1;\r\n            const withinRange = this.withinRange( previousIndex );\r\n            if ( withinRange ){\r\n                return this.items[ previousIndex ];\r\n            }\r\n            if ( !withinRange && allowLoop ){\r\n                return this.getLast();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    get [ Symbol.toStringTag ]() {\r\n        return \"Container\";\r\n    }\r\n}","import {objReduce} from \"../../utils/object\";\r\nimport {isFunction, isPlainObject, isStringNotEmpty} from \"../../utils/is\";\r\nimport makeSelector from \"../../utils/makeSelector\";\r\nimport Emitter from \"../../utils/Emitter\";\r\nimport {asyncForEach} from \"../../utils/iasync\";\r\nimport TypeParser from \"./TypeParser\";\r\nimport Container from \"./Container\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @callback Parser~ctor\r\n * @param {Plugin} plugin\r\n * @param {string} name\r\n * @returns Parser\r\n */\r\n/**\r\n * @typedef {object} ParserDefinition\r\n * @property {string} name\r\n * @property {Parser~ctor} ctor\r\n */\r\n/**\r\n * If just a string, a new instance of the default parser is registered using the new name. If an array, the first element is the name, the second is the custom parser constructor.\r\n * @typedef {string|[string,Parser~ctor]} parserDefinition\r\n */\r\n/**\r\n * @typedef {object} Parser~Configuration\r\n * @property {typeParserDefinition[]} [__types__]\r\n * @property {number} [priority=49]\r\n * @property {string[]} [include]\r\n * @property {string[]} [exclude]\r\n * @property {{options:?string,items:?string}} [data]\r\n * @property {propertyParserDefinition[]} [defaultProperties]\r\n */\r\n/**\r\n * @typedef {object} ParserChange\r\n * @property {Item[]} added\r\n * @property {Item[]} removed\r\n */\r\n\r\n//endregion\r\n\r\nexport const PARSER_DEFAULTS = {\r\n    __types__: [\"image\",\"iframe\"],\r\n    priority: 49,\r\n    include: [\".foobox,[data-foobox],[data-foobox-items]\"],\r\n    exclude: [\".nolightbox\"],\r\n    data: {\r\n        options: \"foobox\",\r\n        items: \"fooboxItems\",\r\n    },\r\n    defaultProperties: [{\r\n        name: \"url\",\r\n        obj: [\"url\",\"href\"],\r\n        elem: [\"data:href\",\"data:url\",\"href\"],\r\n        required: true,\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"title\",\r\n        obj: [\"title\"],\r\n        elem: [\"data:title\", \"title\", \"img/title\"],\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"description\",\r\n        obj: [\"description\"],\r\n        elem: [\"data:description\", \"img/alt\"],\r\n        test: isStringNotEmpty\r\n    },{\r\n        name: \"width\",\r\n        obj: [\"width\"],\r\n        elem: [\"data:width\"]\r\n    },{\r\n        name: \"height\",\r\n        obj: [\"height\"],\r\n        elem: [\"data:height\"]\r\n    },{\r\n        name: \"aspectRatio\",\r\n        obj: [\"aspectRatio\"],\r\n        elem: [\"data:aspectRatio\"]\r\n    }],\r\n    image: {\r\n        priority: 10,\r\n        include: [\r\n            \"[href^='http'][href*='.svg']\",\r\n            \"[href^='http'][href*='.png']\",\r\n            \"[href^='http'][href*='.jpg']\",\r\n            \"[href^='http'][href*='.jpeg']\",\r\n            \"[href^='http'][href*='.webp']\",\r\n            \"[href^='http'][href*='.gif']\",\r\n            \"[href^='http'][href*='.bmp']\",\r\n            \"[href^='http'][href*='fakeimg.pl']\",\r\n            \"[href^='http'].foobox-image\"\r\n        ],\r\n        exclude: []\r\n    },\r\n    iframe: {\r\n        priority: 20,\r\n        include: [\r\n            \"[href^='http'][target='foobox']\",\r\n            \"[href^='http'].foobox-iframe\"\r\n        ],\r\n        exclude: []\r\n    }\r\n};\r\n\r\nexport const PARSER_DEFAULTS_PRO = {\r\n    ...PARSER_DEFAULTS,\r\n    __types__: [\r\n        ...PARSER_DEFAULTS.__types__,\r\n        \"video\"\r\n    ],\r\n    video: {\r\n        priority: 15,\r\n        include: [\r\n            \"[href^='http'][href*='youtube.com/watch']\",\r\n            \"[href^='http'][href*='youtube.com/v']\",\r\n            \"[href^='http'][href*='youtube.com/embed']\",\r\n            \"[href^='http'][href*='youtube-nocookie.com/watch']\",\r\n            \"[href^='http'][href*='youtube-nocookie.com/v']\",\r\n            \"[href^='http'][href*='youtube-nocookie.com/embed']\",\r\n            \"[href^='http'][href*='youtu.be/']\",\r\n            \"[href^='http'][href*='vimeo.com/']:not([href*='vimeo.com/user'])\",\r\n            \"[href^='http'][href*='.mp4']\",\r\n            \"[href^='http'][href*='.ogv']\",\r\n            \"[href^='http'][href*='.wmv']\",\r\n            \"[href^='http'][href*='.webm']\"\r\n        ],\r\n        properties: [{\r\n            name: \"cover\",\r\n            obj: [\"cover\"],\r\n            elem: [\"data:cover\"],\r\n            test: isStringNotEmpty\r\n        }]\r\n    }\r\n};\r\n\r\n/**\r\n * The base parser class.\r\n * @class\r\n */\r\nexport default class Parser extends Emitter {\r\n\r\n    //region static\r\n\r\n    /**\r\n     * @param {parserDefinition} configuration\r\n     * @returns {?ParserDefinition}\r\n     */\r\n    static DEFINITION( configuration ){\r\n        if ( isStringNotEmpty( configuration ) ){\r\n            return { name: /** @type string */ configuration, ctor: /** @type Parser~ctor */ Parser };\r\n        }\r\n        if ( Array.isArray( configuration ) && configuration.length === 2 && isStringNotEmpty( configuration[0] ) && isFunction( configuration[1] ) ){\r\n            return { name: configuration[0], ctor: configuration[1] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Plugin} plugin\r\n     * @param {parserDefinition} definition\r\n     * @returns {?Parser}\r\n     */\r\n    static create( plugin, definition ){\r\n        const def = Parser.DEFINITION( definition );\r\n        return def ? new def.ctor( plugin, def.name ) : null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Plugin} plugin\r\n     * @param {parserDefinition[]} parserDefinitions\r\n     * @returns {Parser[]}\r\n     */\r\n    static createAll( plugin, parserDefinitions ){\r\n        return parserDefinitions.reduce( ( result, config ) => {\r\n            const parser = Parser.create( plugin, config );\r\n            if ( parser ) result.push( parser );\r\n            return result;\r\n        },/** @type {Parser[]} */ [] ).sort( ( a, b ) => a.priority - b.priority );\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region constructor\r\n\r\n    /**\r\n     * Create a new instance of the Parser class.\r\n     * @param {Plugin} plugin - The parent for this instance.\r\n     * @param {string} name - The name the parser was registered with.\r\n     */\r\n    constructor( plugin, name ) {\r\n        super( { bubbles: true }, plugin );\r\n        this.#plugin = plugin;\r\n        this.#name = name;\r\n        this.#priority = this.config.priority;\r\n        this.#includeSelector = makeSelector( this.config.include );\r\n        this.#excludeSelector = makeSelector( this.config.exclude );\r\n        this.#types = TypeParser.createAll( this, this.config.__types__ );\r\n        this.#typesSelector = makeSelector( this.#types.map( ( type ) => type.includeSelector ) );\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region properties\r\n\r\n    /**\r\n     * The private field used by the 'plugin' read-only property.\r\n     * @type {Plugin}\r\n     * @private\r\n     */\r\n    #plugin;\r\n    /**\r\n     * Get the plugin for the parser.\r\n     * @type {Plugin}\r\n     * @readonly\r\n     */\r\n    get plugin(){\r\n        return this.#plugin;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'name' read-only property.\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    #name;\r\n    /**\r\n     * Get the name the parser was registered with.\r\n     * @type {string}\r\n     */\r\n    get name(){\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * The current parser configuration.\r\n     * @type {Parser~Configuration}\r\n     * @readonly\r\n     */\r\n    get config(){\r\n        if ( isPlainObject( this.plugin.config[ this.name ] ) ){\r\n            return this.plugin.config[ this.name ];\r\n        }\r\n        return this.plugin.config[ this.name ] = { __types__: [] };\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'priority' read-only property.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    #priority;\r\n    /**\r\n     * Get the priority.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    get priority(){\r\n        return this.#priority;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'includeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #includeSelector;\r\n    /**\r\n     * Get the result of combining all configured include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get includeSelector(){\r\n        return this.#includeSelector;\r\n    }\r\n\r\n    /**\r\n     * The private field used by the 'excludeSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #excludeSelector;\r\n    /**\r\n     * Get the result of combining all configured exclude selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get excludeSelector(){\r\n        return this.#excludeSelector;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {TypeParser[]}\r\n     */\r\n    #types = [];\r\n\r\n    /**\r\n     * The private field used by the 'typesSelector' read-only property.\r\n     * @type {?string}\r\n     * @private\r\n     */\r\n    #typesSelector;\r\n    /**\r\n     * Get the result of combining all configured type parser include selectors into one.\r\n     * @type {?string}\r\n     * @readonly\r\n     */\r\n    get typesSelector(){\r\n        return this.#typesSelector;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Container>}\r\n     */\r\n    #containerCache = new Map();\r\n    /**\r\n     *\r\n     * @type {Map<*, object>}\r\n     */\r\n    #dataCache = new Map();\r\n\r\n    /**\r\n     * Whether the parseDocument method should be called.\r\n     * @type {boolean}\r\n     * @readonly\r\n     */\r\n    get isDocumentParser(){ return true; }\r\n\r\n    //endregion\r\n\r\n    //region methods\r\n\r\n    /**\r\n     * Checks if the supplied reference is included by this instance.\r\n     * NOTE: This DOES NOT check for exclusions! Use the canParse method if you want to check if a reference is both included AND NOT excluded.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    includes( ref ){\r\n        if ( ref instanceof HTMLElement ){\r\n            return this.includeSelector !== null && ref.matches( this.includeSelector );\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference is excluded by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    excludes( ref ){\r\n        if ( ref instanceof HTMLElement ){\r\n            return this.excludeSelector !== null && ref.matches( this.excludeSelector );\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the supplied reference can be parsed by this instance.\r\n     * @param {*} ref - The object to test.\r\n     * @returns {boolean}\r\n     */\r\n    canParse( ref ){\r\n        return this.includes( ref ) && !this.excludes( ref );\r\n    }\r\n\r\n    /**\r\n     * Gets any configured data for an element reference.\r\n     * @param {HTMLElement} ref\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {Object}\r\n     */\r\n    data( ref, nocache ){\r\n        if ( !nocache && this.#dataCache.has( ref ) ){\r\n            return this.#dataCache.get( ref );\r\n        }\r\n        const dataConfig = this.config.data;\r\n        const result = objReduce( dataConfig, ( result, dataName, key ) => {\r\n            if ( isStringNotEmpty( dataName ) && ref.dataset.hasOwnProperty( dataName ) ){\r\n                let data;\r\n                try {\r\n                    data = JSON.parse( ref.dataset[ dataName ] );\r\n                } catch ( err ) {\r\n                    console.error( `Invalid dataset.${dataName} JSON string supplied.`, ref.dataset, dataName, err );\r\n                    data = null; // cache a null for errors so they will only be triggered again when the cache is flushed\r\n                } finally {\r\n                    result[ key ] = data;\r\n                }\r\n            } else {\r\n                result[ key ] = null;\r\n            }\r\n            return result;\r\n        }, {} );\r\n        this.#dataCache.set( ref, result );\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Parses the document and returns an array of new Containers.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Promise<Container[]>}\r\n     */\r\n    async parseDocument( handledRefs, nocache ){\r\n        const results = [];\r\n        for ( const selector of this.config.include ){\r\n            await asyncForEach( document.querySelectorAll( selector ), ( ref ) => {\r\n                if ( handledRefs.has(ref) || this.excludes( ref ) ) return;\r\n                const container = this.parse( ref, handledRefs, nocache );\r\n                if ( !container ) return;\r\n                results.push( container );\r\n                handledRefs.add( ref );\r\n            });\r\n        }\r\n        this.purgeCache( results );\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Purges the internal cache given the results of the last parseDocument call.\r\n     * @param {Container[]} results\r\n     */\r\n    purgeCache( results ){\r\n        for ( const container of this.#containerCache.values() ){\r\n            if ( !results.includes( container ) || this.shouldPurge( container ) ){\r\n                this.#containerCache.delete( container.ref );\r\n                this.trigger( \"removed-container\", [ container ] );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a container should be purged from cache.\r\n     * @param {Container} container\r\n     * @returns {boolean}\r\n     */\r\n    shouldPurge( container ){\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} ref\r\n     * @param {boolean} [nocache=false]\r\n     * @returns {{itemRefs:Iterable, options:object, trigger:?EventTarget}}\r\n     */\r\n    getArgs( ref, nocache ){\r\n        let trigger = null, itemRefs = [], options = {};\r\n        if ( ref instanceof HTMLElement ){\r\n            const data = this.data( ref, nocache );\r\n            if ( isPlainObject( data.options ) ){\r\n                options = data.options;\r\n            }\r\n            if ( Array.isArray( data.items ) ){\r\n                trigger = ref;\r\n                itemRefs.push( ...data.items );\r\n            } else {\r\n                if ( ref.matches( this.typesSelector ) ){\r\n                    itemRefs.push( ref );\r\n                }\r\n                itemRefs.push( ...ref.querySelectorAll( this.typesSelector ) );\r\n            }\r\n        }\r\n        return { options, itemRefs, trigger };\r\n    }\r\n\r\n    /**\r\n     * Create a new container\r\n     * @param {*} ref\r\n     * @param {object} [options]\r\n     * @param {?EventTarget} [trigger]\r\n     * @returns {?Container}\r\n     */\r\n    create( ref, options, trigger ){\r\n        if ( ref instanceof HTMLElement ){\r\n            return new Container( this, ref, options, trigger );\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new Container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Container|null}\r\n     */\r\n    parse( ref, handledRefs, nocache ){\r\n        const { itemRefs, options, trigger } = this.getArgs( ref, nocache );\r\n        let container, cached = false;\r\n        if ( this.#containerCache.has( ref ) ){\r\n            container = this.#containerCache.get( ref );\r\n            cached = true;\r\n        } else {\r\n            container = this.create( ref, options, trigger );\r\n        }\r\n        if ( container instanceof Container ){\r\n            const items = this.parseItems( container, itemRefs, handledRefs, nocache );\r\n            if ( cached ){\r\n                // compare items\r\n                const changes = this.compareItems( items, container.items );\r\n                container.items.length = 0;\r\n                container.items.push( ...items );\r\n                if ( changes.added.length > 0 || changes.removed.length > 0 ){\r\n                    this.trigger( \"updated-container\", [ container, changes ] );\r\n                }\r\n            } else {\r\n                container.items.push( ...items );\r\n                this.trigger( \"added-container\", [ container ] );\r\n            }\r\n            this.#containerCache.set( ref, container );\r\n        }\r\n        return container;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied iterable collection of objects and returns an array of new ContainerItems.\r\n     * @param {Container} parent - The parent container for the items.\r\n     * @param {Iterable} refs - An iterable collection of reference objects to parse.\r\n     * @param {Set<*>} [handledRefs] - A collection of all references already handled by the plugin.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Item[]}\r\n     */\r\n    parseItems( parent, refs, handledRefs, nocache ){\r\n        const results = [];\r\n        for ( const ref of refs ){\r\n            if ( handledRefs.has( ref ) || this.excludes( ref ) ) continue;\r\n            const item = this.parseItem( parent, ref, nocache );\r\n            if ( !item ) continue;\r\n            results.push( item );\r\n            handledRefs.add( ref );\r\n        }\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Parses the supplied reference object and returns a new ContainerItem.\r\n     * @param {Container} parent - The parent container for the item.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - If set to true any internal caching mechanisms are ignored and subsequently updated with freshly parsed values.\r\n     * @returns {Item|null} Returns null if parsing fails or no type can parse the reference object.\r\n     */\r\n    parseItem( parent, ref, nocache  ){\r\n        const type = this.#types.find( ( type ) => type.canParse( ref ) );\r\n        return type ? type.parse( parent, ref, nocache ) : null;\r\n    }\r\n\r\n    /**\r\n     * Compares a containers current items against its cached items and reports any changes.\r\n     * @param {Item[]} current\r\n     * @param {Item[]} cached\r\n     * @returns {ParserChange}\r\n     */\r\n    compareItems( current, cached ){\r\n        const removed = cached.filter( ( item ) => !current.includes( item ) );\r\n        const added = current.filter( ( item ) => !cached.includes( item ) );\r\n        return { removed, added };\r\n    }\r\n\r\n    //endregion\r\n}","import { defaults, extend } from \"../../utils/object\";\r\nimport { isFunction, isNumber, isString, isStringNotEmpty } from \"../../utils/is\";\r\nimport { asyncForEach } from \"../../utils/iasync\";\r\nimport Emitter from \"../../utils/Emitter\";\r\nimport Parser from \"./Parser\";\r\n\r\n/**\r\n * @extends Emitter\r\n */\r\nclass Plugin extends Emitter {\r\n\r\n    constructor( configuration ) {\r\n        super();\r\n        this.config = defaults( configuration, this.config );\r\n        this.on( {\r\n            \"added-container\": this.#onAddedContainer,\r\n            \"removed-container\": this.#onRemovedContainer,\r\n            \"updated-container\": this.#onUpdatedContainer\r\n        }, this );\r\n    }\r\n\r\n    isParser( value ){\r\n        return value === Parser;\r\n    }\r\n\r\n    //region Properties\r\n\r\n    /**\r\n     *\r\n     * @type {object}\r\n     */\r\n    config = { __parsers__: [] };\r\n\r\n    /**\r\n     *\r\n     * @type {MutationObserver|null}\r\n     */\r\n    #observer = null;\r\n\r\n    /**\r\n     *\r\n     * @type {Map<*, Container>}\r\n     */\r\n    #containers = new Map();\r\n\r\n    /**\r\n     *\r\n     * @type {Map<EventTarget, EventListener>}\r\n     */\r\n    #triggers = new Map();\r\n\r\n    /**\r\n     * Used to ensure multiple calls to the parseDocument method during parsing all return the same result instead of simply kicking off multiple parses.\r\n     * @type {Promise<Container[]>}\r\n     * @private\r\n     */\r\n    #parseDocument = null;\r\n\r\n    /**\r\n     *\r\n     * @type {Parser[]}\r\n     */\r\n    #parsers = [];\r\n\r\n    /**\r\n     *\r\n     * @type {Parser[]}\r\n     * @readonly\r\n     */\r\n    get __parsers__(){\r\n        return this.#parsers;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //#region readyState\r\n\r\n    /**\r\n     * 0 - The plugin script has been evaluated but not yet initialized.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 0\r\n     */\r\n    get RS_DEFAULT(){ return 0; }\r\n\r\n    /**\r\n     * 1 - The configuration has been set but components have not been loaded yet.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 1\r\n     */\r\n    get RS_INITIALIZING(){ return 1; }\r\n\r\n    /**\r\n     * 2 - The components are loaded but long-running tasks have not been run.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 2\r\n     */\r\n    get RS_INITIALIZED(){ return 2; }\r\n\r\n    /**\r\n     * 3 - Long-running tasks have completed. The plugin is now ready.\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 3\r\n     */\r\n    get RS_READY(){ return 3; }\r\n\r\n    /**\r\n     *\r\n     * @type {number}\r\n     */\r\n    #readyStateValue = this.RS_DEFAULT;\r\n\r\n    /**\r\n     * Get the current readyState\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 0\r\n     */\r\n    get readyState(){\r\n        return this.#readyStateValue;\r\n    }\r\n\r\n    /**\r\n     * Set the readyState value and trigger the \"readystatechange\" event.\r\n     * @private\r\n     * @param {number} value\r\n     * @fires Document#foobox-readystatechange\r\n     * @fires Plugin#readystatechange\r\n     * @throws {TypeError} Throws a TypeError if the value is not a number.\r\n     * @throws {RangeError} Throws a RangeError if the value is less than the current value or more than the RS_READY value.\r\n     */\r\n    set #readyState( value ){\r\n        if ( this.#readyStateValue === value ) return; // do nothing\r\n        if ( !isNumber( value ) ) throw new TypeError( \"The 'value' argument must be a number.\" );\r\n        if ( value < this.#readyStateValue ) throw new RangeError( \"The 'value' argument can't be less than the current readyState.\" );\r\n        if ( value > this.RS_READY ) throw new RangeError( \"The 'value' argument can't be more than the RS_READY value.\" );\r\n        this.#readyStateValue = value;\r\n        /**\r\n         * Occurs whenever the readyState is changed.\r\n         * @event Document#foobox-readystatechange\r\n         * @param {CustomEvent} event - The readyState value can be accessed using the CustomEvent.detail property which is set to the plugin instance. e.g. event.detail.readyState\r\n         */\r\n        this.documentDispatch( \"foobox-readystatechange\" );\r\n        /**\r\n         * Occurs whenever the readyState is changed.\r\n         * @event Plugin#readystatechange\r\n         * @param {EmitterEvent} event - The basic event object.\r\n         * @param {number} readyState - The readyState value.\r\n         */\r\n        this.trigger( \"readystatechange\", [ value ] );\r\n\r\n        const states = [ 'evaluated', 'initializing', 'initialized', 'ready' ];\r\n        this.documentDispatch( `foobox-${ states[ value ] }` );\r\n        this.trigger( states[ value ] );\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //region Methods\r\n\r\n    /**\r\n     *\r\n     * @param configuration\r\n     */\r\n    async init( configuration ) {\r\n        if ( this.readyState !== this.RS_DEFAULT ) return;\r\n        this.#readyState = this.RS_INITIALIZING;\r\n        extend( this.config, configuration );\r\n        this.#parsers = Parser.createAll( this, this.config.__parsers__ );\r\n        this.#readyState = this.RS_INITIALIZED;\r\n        await this.parseDocument( true );\r\n        this.#readyState = this.RS_READY;\r\n        this.observe();\r\n    }\r\n\r\n    /**\r\n     * Dispatch an event on the document.\r\n     * @param {string|Event} event - If given a string a CustomEvent is dispatched using the value as the type.\r\n     * @param {eventOptions} [options] - Any additional options for the event. By default the detail option of CustomEvent objects created by this method is set to the plugin instance.\r\n     * @returns {boolean}\r\n     */\r\n    documentDispatch( event, options ){\r\n        /** @typedef {{bubbles:?boolean,cancelable:?boolean,composed:?boolean,detail:*}} eventOptions */\r\n        if ( isString( event ) ){\r\n            event = new CustomEvent( event, extend( { detail: this }, options ) );\r\n        }\r\n        if ( event instanceof Event ){\r\n            return document.dispatchEvent( event );\r\n        }\r\n        return false;\r\n    }\r\n\r\n    observe(){\r\n        if ( !this.config.watch ) return;\r\n        if ( !this.#observer ){\r\n            this.#observer = new MutationObserver( () => {\r\n                this.parseDocument();\r\n            } );\r\n        }\r\n        this.#observer.observe( document, { childList: true, subtree: true } );\r\n    }\r\n\r\n    unobserve(){\r\n        if ( !this.config.watch || !this.#observer ) return;\r\n        this.#observer.disconnect();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @param {object} [configuration]\r\n     * @param {Parser~ctor} [ctor]\r\n     * @returns {boolean}\r\n     */\r\n    registerParser( name, configuration, ctor ){\r\n        if ( this.readyState < this.RS_INITIALIZED && !this.config.hasOwnProperty( name ) ){\r\n            const Parser_ctor = isFunction( ctor ) ? ctor : Parser;\r\n            this.config.__parsers__.push( [ name, Parser_ctor ] );\r\n            this.config[ name ] = extend( {}, configuration );\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @returns {boolean}\r\n     */\r\n    unregisterParser( name ){\r\n        if ( this.readyState < this.RS_INITIALIZED && this.config.hasOwnProperty( name ) ){\r\n            this.config.__parsers__ = this.config.__parsers__.filter( ( config ) => {\r\n                const parser = Parser.DEFINITION( config );\r\n                return parser ? parser.name !== name : false;\r\n            });\r\n            delete this.config[ name ];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Remove any trigger listeners registered using the addTrigger method.\r\n     * @param {?EventTarget} eventTarget\r\n     */\r\n    removeTriggerListener( eventTarget ){\r\n        if ( eventTarget instanceof EventTarget && this.#triggers.has( eventTarget ) ){\r\n            const listener = this.#triggers.get( eventTarget );\r\n            eventTarget.removeEventListener( \"click\", listener, false );\r\n            this.#triggers.delete( eventTarget );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up a trigger listener on the target.\r\n     * @param {?EventTarget} eventTarget\r\n     * @param {Container} container\r\n     * @param {?Item} [item]\r\n     */\r\n    addTriggerListener( eventTarget, container, item ){\r\n        if ( eventTarget instanceof EventTarget ){\r\n            if ( this.#triggers.has( eventTarget ) ){\r\n                // if there was a listener already cached then remove it before adding the new one\r\n                eventTarget.removeEventListener( \"click\", this.#triggers.get( eventTarget ), false );\r\n            }\r\n            const listener = ( e ) => {\r\n                e.preventDefault();\r\n                this.trigger( \"triggered-container\", [ container, item ] );\r\n            };\r\n            // add the listener to the internal cache, this will update the listener if it existed\r\n            this.#triggers.set( eventTarget, listener );\r\n            eventTarget.addEventListener( \"click\", listener, false );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all document parsers.\r\n     * @returns {Parser[]}\r\n     */\r\n    getDocumentParsers(){\r\n        return this.#parsers.filter( ( parser ) => parser.isDocumentParser );\r\n    }\r\n\r\n    /**\r\n     * Try get a parser for the reference.\r\n     * @param {*} ref\r\n     * @returns {?Parser}\r\n     */\r\n    getRefParser( ref ){\r\n        return this.#parsers.find( ( parser ) => parser.canParse( ref ) ) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Get all containers for this instance of the plugin.\r\n     * @returns {Container[]}\r\n     */\r\n    getAll(){\r\n        return Array.from( this.#containers.values() );\r\n    }\r\n\r\n    /**\r\n     * Given a reference or selector this method attempts to return the associated container.\r\n     * @param {*} ref\r\n     * @return {Container|null}\r\n     */\r\n    find( ref ){\r\n        if ( this.#containers.has( ref ) ){\r\n            return this.#containers.get( ref );\r\n        }\r\n        if ( isStringNotEmpty( ref ) ){\r\n            const elementRef = document.querySelector( ref );\r\n            if ( elementRef && this.#containers.has( elementRef ) ){\r\n                return this.#containers.get( elementRef );\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a collection of references from all containers and items.\r\n     * @param {*} excludeRef - A reference to exclude from the result.\r\n     * @returns {Set<*>}\r\n     */\r\n    getRefs( excludeRef ){\r\n        /** @type {Set<*>} */\r\n        const refs = new Set();\r\n        return this.getAll().reduce( ( result, container ) => {\r\n            if ( container.ref !== excludeRef ){\r\n                result.add( container.ref );\r\n                container.items.forEach( ( item ) => {\r\n                    if ( item.ref === excludeRef ) return;\r\n                    result.add( item.ref );\r\n                } );\r\n            }\r\n            return result;\r\n        }, refs);\r\n    }\r\n\r\n    /**\r\n     * Parses the entire document and returns an array of Container objects.\r\n     * @async\r\n     * @param {boolean} [nocache=false] - Whether to disable the parser cache for this call.\r\n     * @returns {Promise<Container[]>} Returns an empty array if no Containers were parsed.\r\n     */\r\n    async parseDocument( nocache ){\r\n        // if the plugin is not initialized yet return an empty array as we have no parsers to work with\r\n        if ( this.readyState < this.RS_INITIALIZED ) return [];\r\n        // if there is already parsing taking place simply return a reference to its promise\r\n        if ( this.#parseDocument ) return this.#parseDocument;\r\n        // otherwise we need to do some work\r\n        nocache = nocache ?? false;\r\n        return this.#parseDocument = new Promise( async ( resolve ) => {\r\n            const results = [], handledRefs = new Set();\r\n            await asyncForEach( this.getDocumentParsers(), async ( parser ) => {\r\n                const containers = await parser.parseDocument( handledRefs, nocache );\r\n                results.push( ...containers );\r\n            });\r\n            this.#parseDocument = null;\r\n            resolve( results );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parse the supplied reference object into a Container.\r\n     * @param {*} ref - The object to parse.\r\n     * @param {boolean} [nocache=false] - Whether to disable the parser caching for this call.\r\n     * @returns {Container|null} Returns null if the reference object could not be parsed.\r\n     */\r\n    parse( ref, nocache ){\r\n        if ( this.readyState < this.RS_INITIALIZED ) return null;\r\n        nocache = nocache ?? false;\r\n        const parser = this.getRefParser( ref );\r\n        if ( parser ){\r\n            const handledRefs = this.getRefs( ref );\r\n            return parser.parse( ref, handledRefs, nocache );\r\n        }\r\n        return null;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region listeners\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     */\r\n    #onAddedContainer( event, container ){\r\n        this.addTriggerListener( container.triggerTarget, container );\r\n        container.items.forEach( ( item ) => this.addTriggerListener( item.triggerTarget, container, item ) );\r\n        this.#containers.set( container.ref, container );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     * @param {ParserChange} changes\r\n     */\r\n    #onUpdatedContainer( event, container, changes ){\r\n        changes.removed.forEach( ( item ) => this.removeTriggerListener( item.triggerTarget ) );\r\n        changes.added.forEach( ( item ) => this.addTriggerListener( item.triggerTarget, container, item ) );\r\n        this.#containers.set( container.ref, container );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {EmitterEvent} event\r\n     * @param {Container} container\r\n     */\r\n    #onRemovedContainer( event, container ){\r\n        this.removeTriggerListener( container.triggerTarget );\r\n        container.items.forEach( ( item ) => this.removeTriggerListener( item.triggerTarget ) );\r\n        this.#containers.delete( container.ref );\r\n    }\r\n\r\n    //endregion\r\n}\r\n\r\nexport default Plugin;","import {isStringNotEmpty} from \"../../utils/is\";\r\nimport {asyncForEach} from \"../../utils/iasync\";\r\nimport Parser, { PARSER_DEFAULTS, PARSER_DEFAULTS_PRO } from \"./Parser\";\r\nimport Container from \"./Container\";\r\n\r\n//region type-definitions\r\n\r\n/**\r\n * @typedef {Parser~Configuration} GroupParser~Configuration\r\n * @property {number} [priority=99]\r\n */\r\n\r\n//endregion\r\n\r\nexport const GROUP_PARSER_DEFAULTS = {\r\n    ...PARSER_DEFAULTS,\r\n    priority: 99,\r\n    include: []\r\n};\r\n\r\nexport const GROUP_PARSER_DEFAULTS_PRO = {\r\n    ...PARSER_DEFAULTS_PRO,\r\n    priority: 99,\r\n    include: []\r\n};\r\n\r\nexport default class GroupParser extends Parser {\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    async parseDocument( handledRefs, nocache ) {\r\n        const results = [];\r\n        await asyncForEach( this.config.include, ( selector ) => {\r\n            if ( !handledRefs.has( selector ) ){\r\n                const container = this.parse( selector, handledRefs, nocache );\r\n                if ( container && container.items.length ){\r\n                    results.push( container );\r\n                    handledRefs.add( selector );\r\n                }\r\n            }\r\n        } );\r\n        this.purgeCache( results );\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    shouldPurge( container ) {\r\n        return container.items.length === 0;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    create( ref, options, trigger ){\r\n        if ( isStringNotEmpty( ref ) ){\r\n            return new Container( this, ref, options, trigger );\r\n        }\r\n        return super.create( ref, options, trigger );\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    getArgs( ref, nocache ) {\r\n        if ( isStringNotEmpty( ref ) ){\r\n            return { trigger: null, options: {}, itemRefs: document.querySelectorAll( ref ) };\r\n        }\r\n        return super.getArgs( ref, nocache );\r\n    }\r\n\r\n}","import utils from \"../../utils\";\r\n\r\nimport Plugin from \"./Plugin\";\r\nimport Parser, { PARSER_DEFAULTS } from \"./Parser\";\r\nimport GroupParser, { GROUP_PARSER_DEFAULTS } from \"./GroupParser\";\r\n\r\nconst plugin = new Plugin( {\r\n    __parsers__: [\r\n        [\"default\", Parser],\r\n        [\"groups\", GroupParser]\r\n    ],\r\n    default: PARSER_DEFAULTS,\r\n    groups: GROUP_PARSER_DEFAULTS,\r\n    watch: false\r\n} );\r\n\r\nplugin.utils = utils;\r\nplugin.Plugin = Plugin;\r\nplugin.Parser = Parser;\r\nplugin.GroupParser = GroupParser;\r\nplugin.PARSER_DEFAULTS = PARSER_DEFAULTS;\r\nplugin.GROUP_PARSER_DEFAULTS = GROUP_PARSER_DEFAULTS;\r\n\r\nexport default plugin;","/**\r\n * Check if the value is a boolean.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isBoolean(value){\r\n    return value != null && '[object Boolean]' === Object.prototype.toString.call(value);\r\n}\r\n\r\n/**\r\n * Check if the value is a function.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isFunction(value){\r\n    return value != null && (Object.prototype.toString.call(value) === \"[object Function]\" || typeof value === \"function\" || value instanceof Function);\r\n}\r\n\r\n/**\r\n * Check if the value is a number.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isNumber(value){\r\n    return value != null && '[object Number]' === Object.prototype.toString.call(value) && !isNaN(value);\r\n}\r\n\r\n/**\r\n * Check if the value is an object.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isObject(value){\r\n    return value != null && typeof value === \"object\";\r\n}\r\n\r\n/**\r\n * Check if the value is a plain object.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isPlainObject(value){\r\n    if (isObject(value)){\r\n        const proto = Object.getPrototypeOf(value);\r\n        return proto === Object.prototype || proto === null;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Check if the value is a promise.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isPromise(value){\r\n    return value != null && value instanceof Promise;\r\n}\r\n\r\n/**\r\n * Check if the value is a string.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isString(value){\r\n    return value != null && '[object String]' === Object.prototype.toString.call(value);\r\n}\r\n\r\nconst isEmptyString = /^\\s*$/;\r\n/**\r\n * Check if the value is a string and is not empty.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isStringNotEmpty(value){\r\n    return isString(value) && !isEmptyString.test(value);\r\n}\r\n\r\n/**\r\n * Check if the value is a undefined.\r\n * @param {*} value\r\n * @returns {boolean}\r\n */\r\nfunction isUndefined(value){\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport {\r\n    isBoolean,\r\n    isFunction,\r\n    isNumber,\r\n    isObject,\r\n    isPlainObject,\r\n    isPromise,\r\n    isString,\r\n    isStringNotEmpty,\r\n    isUndefined\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t958: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkfoobox\"] = self[\"webpackChunkfoobox\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(80);\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","hasProperty","target","propertyName","isPlainObject","isStringNotEmpty","indexOf","hasOwnProperty","names","split","length","last","index","currentTarget","name","removeProperty","getProperty","defaultValue","setProperty","value","isUndefined","merge","source","objForEach","key","Array","isArray","slice","extend","sources","reduce","result","mergeMissing","missing","defaults","callback","Object","keys","forEach","call","this","objReduce","callbackFn","initialValue","previousValue","is","obj","async","doCallback","args","Promise","resolve","setTimeout","asyncForEach","iterable","i","constructor","type","options","parsed","Emitter","namespace","isBoolean","bubbles","cancelable","defaultPrevented","emitterInstance","TypeError","currenTarget","preventDefault","isDefaultPrevented","stopPropagation","isPropagationStopped","static","required","parsedType","n_index","EVENT_TYPE_NAMESPACE_SEPARATOR","parentEmitter","Map","__events__","__emitterEventDefaults__","__parentEmitter__","listener","thisArg","isFunction","eventType","parseType","namespaces","get","set","listeners","thisArgs","Set","add","types","push","has","delete","size","on","typeOrTypeMap","typeListenerOrTypeMapThisArg","typeThisArg","arguments","off","emit","event","EmitterEvent","trigger","map","every","success","filter","val","join","PropertyParser","property","configuration","ctor","equalityComparer","sourceValue","some","targetValue","includes","mergeArray","targetDefinition","sourceDefinition","targetDef","DEFINITION","sourceDef","typeParser","definition","def","propertyParserDefinitions","propertyParser","create","ref","properties","nocache","getValue","test","convert","DEFAULT_CONVERT","DEFAULT_TEST","queryParent","queryPath","queryType","query","objectQuery","elem","elementQuery","parser","path","parts","pop","part","raw","targetRef","parents","selector","parentElement","querySelector","dataset","hasAttribute","getAttribute","HTMLElement","prop","Item","parent","requiredProperties","triggerTarget","EventTarget","getProperties","TypeParser","typeParserDefinitions","config","sort","a","b","priority","makeSelector","include","exclude","createAll","MERGE_DEFINITIONS","defaultProperties","includeSelector","excludeSelector","matches","excludes","canParse","parse","item","getTrigger","getRequiredProperties","getValues","Container","items","firstIndex","lastIndex","withinRange","isNumber","getByIndex","getFirst","getLast","getNext","current","allowLoop","nextIndex","getPrevious","previousIndex","toStringTag","Symbol","PARSER_DEFAULTS","__types__","data","image","iframe","Parser","plugin","parserDefinitions","super","typesSelector","isDocumentParser","dataName","JSON","err","console","error","handledRefs","results","document","querySelectorAll","container","purgeCache","values","shouldPurge","getArgs","itemRefs","cached","parseItems","changes","compareItems","added","removed","refs","parseItem","find","isParser","__parsers__","RS_DEFAULT","RS_INITIALIZING","RS_INITIALIZED","RS_READY","readyState","RangeError","documentDispatch","states","parseDocument","observe","isString","CustomEvent","detail","Event","dispatchEvent","watch","MutationObserver","childList","subtree","unobserve","disconnect","registerParser","Parser_ctor","unregisterParser","removeTriggerListener","eventTarget","removeEventListener","addTriggerListener","e","addEventListener","getDocumentParsers","getRefParser","getAll","from","elementRef","getRefs","excludeRef","containers","GROUP_PARSER_DEFAULTS","GroupParser","Plugin","default","groups","utils","prototype","toString","Function","isNaN","isObject","proto","getPrototypeOf","isPromise","isEmptyString","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","O","chunkIds","fn","notFulfilled","Infinity","fulfilled","j","splice","r","d","o","defineProperty","enumerable","g","globalThis","window","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","id","chunkLoadingGlobal","self","bind","__webpack_exports__"],"sourceRoot":""}